---
title: "CORS(Cross-Origin Resource Sharing)"
excerpt: "SOP 및 CORS 접근 제어 시나리오에 대해 알아보자."
categories:
  - Network
tags:
  - Network
date: 2021-06-08
last_modified_at: 2021-06-08
---

## 1. SOP(Same Origin Policy)

다른 출처의 리소스를 사용하는 것을 제한하는 보안 방식이다. 어플리케이션이 같은 출처에서만 자원을 공유하는 것을 원칙으로 한다.

### 1.1. 출처

```
https://abc.com:443/jinhong?tab=tags#example
```

* URL의 Protocol, Host(Domain), Port를 통해 같은 출처인지 다른 출처인지 판단할 수 있다.
  * 위 세 개가 모두 동일해야 같은 출처로 인식한다.

### 1.2. 사용 이유

출처가 다른 App들이 마음대로 소통할 수 있는 환경은 매우 위험하다. 사용자가 나쁜 마음을 먹는다면 CSRF, XSS 등을 사용해서 필요한 정보를 쉽게 탈취할 수 있다. HTTP 프로토콜의 서버는 기본적으로 무상태성 특징을 가지기 때문에, 별도의 보안 검증 로직이 없는 이상 요청이 진짜 클라이언트의 것인지 해커의 것인지 알 수 없기 때문이다.

해커는 불순한 의도의 스크립트가 담긴 URL을 인증된 클라이언트에게 보내고, 클라이언트가 해당 URL에 접속하면 스크립트가 클라이언트의 토큰을 바탕으로 의도하지 않은 요청을 서버로 보낼 수 있다.

이 때, 브라우저는 서버의 URL과 해커가 만든 요청 URL의 Origin이 다르면 SOP를 위반하다고 판단한다. SOP 정책은 Javascript가 스크립트를 포함하고 있는 문서와 같은 출처의 문서에 있는 Window와 Document 객체의 속성만을 사용할 수 있도록 한다. SOP를 위반하면 해커가 만든 웹 사이트의 스크립트는 동작하지 않게 된다. 즉, 개인정보 유출을 막을 수 있다.

<br>

## 2. CORS(Cross-Origin Resource Sharing)

SOP는 한 웹 사이트내에서만 자원을 접근할 수 있기 때문에, 다른 웹 사이트의 이미지나 글을 가져올 수 없다. 그러나 웹 사이트가 발전함에 따라 오픈된 환경에서 다른 출처의 자원을 사용하고자 하는 수요가 많아졌다. 이에 SOP 정책에 몇 가지 예외적인 경우를 두었고, 그 중 하나가 CORS다.

CORS란 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 어플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에게 알려주는 체제다. 즉, 특정 조건을 만족하면 다른 출처의 자원을 공유하는 것이다.

### 2.1. 접근 제어 시나리오

#### Preflight

1. OPTIONS 메서드를 통해 다른 도메인의 리소스에 요청이 가능한지 확인하는 작업이다.
  * 본 요청을 보내기 전, 서버가 어떤 출처와 방식을 허용하는지 확인한다.
2. 200 응답이 와서 요청이 가능하다면 실제 요청(Actual Request)을 보낸다.

Preflight Request에는 다음과 같은 내용이 포함된다.

* Origin : 요청 출처.
* Access-Control-Request-Method : 실제 요청의 메서드.
* Access-Control-Request-Headers : 실제 요청의 추가 헤더.

Preflight Response에는 다음과 같은 내용이 포함된다.

* Access-Control-Allow-Origin : 서버 측 허가 출처.
* Access-Control-Allow-Methods : 서버 측 허가 메서드.
* Access-Control-Allow-Headers : 서버 측 허가 헤더.
* Access-Control-Max-Age : Preflight 응답 캐시 기간.

#### Simple Request

Preflight 없이 바로 요청을 날리며 다음 조건을 모두 만족해야 한다.

* GET, POST, HEAD 메서드 중 하나여야 한다.
* Content-Type은 ``text/plain``, ``multipart/form-data``, ``application/x-www-form-urlencoded`` 중 하나여야 한다.
* 헤더는 Accept, Accept-Language, Content-Language, Content-Type 만 허용한다.

#### Credentialed Request

쿠키나 JWT 토큰 등 인증 관련 헤더를 포함할 때 사용하는 요청이다.

클라이언트는 ``credentials: include``를 설정해야 하며, 서버는 ``Access-Control-Allow-Credentials: true`` 설정을 해야 한다.

이 때, ``Access-Control-Allow-Origin:*``와 같이 모든 출처를 허용하면 에러가 발생한다. 정확한 출처를 명시해야 한다.

<br>

## 3. 왜 Preflight가 필요할까?

> CORS를 모르는 서버를 위해서이다.

만약 Preflight 없이 브라우저가 요청을 보내면, 서버는 일련의 서비스 로직을 처리한다. 별도의 CORS 설정이 없다면 응답 메시지 헤더에 ``Access-Control-Allow-Origin:none``을 보낼 것이다. 해당 응답을 받은 시점에서 브라우저는 CORS 에러를 띄우겠지만, 이미 서버의 DB는 데이터가 삭제 혹은 수정된 시점이다.

따라서 실제 요청 전에 Preflight 요청을 보냄으로써, CORS를 모르는 서버를 안전하게 지킬 수 있다.

<br>

## 4. CORS 해결하기

### 4.1. Front Proxy Server 설정

![image](https://user-images.githubusercontent.com/56240505/121150469-881d7b00-c87e-11eb-91e5-a332c9f95e71.png)

CORS 위배는 브라우저에서 발생하는 이슈다. 따라서 프론트 서버가 다른 출처로 리소스 요청을 보내며, 브라우저는 SOP를 준수한다고 인식하도록 설정한다.

### 4.2. Spring Boot 설정

* @CrossOrigin 애너테이션을 사용하거나, WebMvcConfigurer에서 corsMapping 설정을 해준다.

<br>

---

## References

* [[10분 테코톡] 🌳 나봄의 CORS](https://www.youtube.com/watch?v=-2TgkKYmJt4)
