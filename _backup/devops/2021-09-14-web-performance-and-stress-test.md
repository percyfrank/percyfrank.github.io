---
title: "웹 성능 진단 및 어플리케이션 성능 테스트"
excerpt: "어플리케이션 성능 측정을 위한 지표들을 알아보자."
categories:
  - DevOps
tags:
  - DevOps
date: 2021-09-14
last_modified_at: 2021-09-14
---

## 1. 인터넷 구간 웹 성능 측정

<img width="1053" alt="스크린샷 2021-09-12 오후 6 36 11" src="https://user-images.githubusercontent.com/56240505/132983092-b2aa7787-c38d-43f2-8050-4191dc03e10f.png">

* [WepPageTest](https://www.webpagetest.org/)를 통해 어플리케이션의 인터넷 구간 웹 성능을 측정한다.
* 사용자는 응답 시간이 20% 이상일 때 차이를 인식하며, 3초안에 로딩되지 않으면 53% 사용자가 떠난다는 결과도 있다.
* 위 사진은 주로 웹 서버에 영향을 받는 지표들이다.

<img width="1049" alt="스크린샷 2021-09-12 오후 6 54 23" src="https://user-images.githubusercontent.com/56240505/132983200-ef38dbf5-0276-4260-aa34-2dd49538959a.png">

* 위 지표들은 정적 컨텐츠 및 네트워크 상태에 영향을 받는 지표들이다.
* 다음 사항들을 고려함으로써 웹 성능을 높일 수 있다.
  * 캐싱
  * CDN
  * keep-alive
  * gzip 및 이미지 압축
  * 불필요한 다운로드 제거 및 작업 지연 로딩
  * 스크립트 병합을 통한 요청수 최소화

<br>

## 2. 웹 성능 예산

![image](https://user-images.githubusercontent.com/56240505/132983555-3e8a23b4-2705-43da-868e-964f1fce46d6.png)

* 성능 목표에는 정답이 없으며, 특정 목표를 성취하기 위해서는 다른 부분을 일정 포기해야하는 등 Trade-Off가 존재한다.
* 따라서 우선 순위 및 서비스 목표 등을 종합 고려하여 웹 성능 예산을 산정해야 한다.
  * 컨텐츠가 빠르게 노출되는 것이 중요한가?
  * 사용자가 관련 링크를 빠르게 클릭하는 것이 중요한가?
* [Page Speed](https://developers.google.com/speed/pagespeed/insights/) 분석 결과를 통해 고려해본다.

### 2.1. 예산 산정

* 예비 분석
  * 우리 서비스에서 중요한 페이지의 FCP 및 TTI 등의 지표는 어떠한가?
* 경쟁사 분석
  * 경쟁사 혹은 유사한 사이트와 20% 이상의 응답 시간이 차이나는지 확인한다.
* 성능 기준 설정
  * 정량 기준
    * 이미지 최대 크기
    * 웹 글꼴 최대 크기
    * 스크립트 최대 갯수
    * 동영상 최대 크기
    * ...
  * 시간 기준
    * FCP 3초 미만
    * TTI 4초 미만
  * 규칙 기준
    * 성능 측정 사이트 지표의 80점 이상
* 우선순위
  * 컨텐츠의 빠른 노출이 중요하다면 FCP
  * 사용자가 관련 링크를 빠르게 클릭해야 한다면 TTI

### 2.2. 웹 성능 예산 예시

![image](https://user-images.githubusercontent.com/56240505/132983594-a4ccfdbd-59d4-4de2-9924-887374c9f8f2.png)

<br>

## 3. 부하 및 스트레스 테스트를 위한 사전 지식 및 용어 정리

* 고가용성 및 무중단 서비스를 지향할 때, 핵심은 사용자가 납득할만한 수준의 가용성과 배포 사이클을 유지하는 것이다.
* 서비스를 배포하기 전에 예상되는 상황을 테스트해야한다.
  * 현재 시스템은 어느 정도의 부하를 견딜 수 있는가?
  * 한계치에서 병목이 생기는 지점은 어디며, 장애 조치 및 복구 계획은 무엇인가?

### 3.1. 가용성

* 시스템이 서비스를 정상적으로 제공할 수 있는 상태를 의미한다.
* 서버 점검 및 어플리케이션 장애 등으로 서비스를 이용할 수 없으면 가용성이 낮아진다.
* 가용성을 높이기 위해 단일 장애점을 없애고, 확장 가능한 서비스를 만들어야 한다.

#### 단일 장애점

* 서버 장비, 어플리케이션 서버, DB 서버가 1대인 경우?
  * 해당 장비 혹은 서버가 장애가 나면 서비스가 중단된다.
* 장비를 이중화하는 경우?
  * 그러나 단순히 장비를 증대하면 각 서버별로 DB 데이터가 분산되어 일관된 응답을 받을 수 없다.
* DNS를 통해 트래픽을 분산시키는 경우?
  * DNS 서버는 WAS의 상태를 확인하지 않기 때문에, WAS가 장애가 나는 경우에도 사용자는 장애 서버로 요청할 수 있다.
  * DNS는 일반적으로 캐싱되므로 사용자가 직접 캐시를 날리지 않는 이상 장애가 유지된다.
* 어플리케이션 서버만 이중화하는 경우?
  * DB 서버 역시 단일장애점이 될 수 있으며, 데이터가 백업이 되지 않는 경우 서비스에 큰 문제를 끼친다.
* 따라서 모든 요소를 다중화해야 한다.

#### 다중화

* 다중화란 장애가 발생해도 예비 운용 장비로 시스템의 기능을 계속할 수 있도록 하는 장애 내성을 뜻한다.
* 단일 장애점을 없애고 무중단 및 고가용성 서비스를 지향하기 위해 다중화가 필요하다.
* 다중화 대상은 서버, 로드 밸런서, 네트워크 장비 등이 될 수 있다.
* Failover는 active-passive 관계를 의미하며, Replication은 master-slave를 의미한다.

### 3.2. 성능

* 성능이란 서비스가 얼마나 빠른지(Time), 일정 시간 동안 얼마나 많이 처리할 수 있는지(TPS), 얼마나 많은 사람들이 동시에 사용할 수 있는지(Users) 등의 지표로 확인할 수 있다.
* 부하란 처리를 실행하려고 해도 실행할 수 없어서 대기하고 있는 프로세스의 수를 의미한다.

#### 사용자

* 사용자는 관점에 따라 다양하게 구분할 수 있다.
  * 등록된 사용자 vs 등록되지 않은 사용자
  * 로그인 사용자 vs 비로그인 사용자
* 테스터의 관점에서 사용자는 Concurrent 사용자와 Active 사용자가 있다.
  * Concurrent 사용자는 웹 페이지를 띄어놓은 사용자처럼, 언제든지 부하를 줄 수 있는 사용자다.
  * Active 사용자(VUser)는 메뉴나 링크를 누르고 결과가 나오기를 기다리는 등 실제로 서버에 부하를 주고 있는 사용자다.
  * 두 유저의 비율은 서비스의 성격에 따라 다르기 때문에 이를 감안해 성능 테스트를 계획해야 한다.

#### 처리량

* 처리량 계산 공식은 다음과 같다.
  * 서비스 처리 건수 / 측정 시간
  * 요청 사용자 수 / 평균 응답시간
  * 동시 사용자 수 / 서비스 요청 간격

![image](https://user-images.githubusercontent.com/56240505/132992323-4c32f043-ec1d-4bb2-8f19-0c7cdafe0d90.png)

* User 증가 시 TPS는 어느 정도 증가하다가 더 이상 증가하지 않게 되며, Time은 일정하게 유지되다 점차적으로 증가한다.
* 부하(TPS)가 증가하면 지연시간은 변곡점에 이르기도 하는데, 이 경우 시스템 리소스가 누수되고 있는 것은 아닌지 확인해야 한다.
* Time과 달리 TPS(Transaction Per Seconds)는 Scale out 혹은 Scale up을 통해 증가시킬 수 있다.
  * 테스트 시에 단순 응답 시간 기준이 아닌 TPS나 DB Connection, CPU 등을 종합적으로 확인하고 중단해야 한다.

#### Performance vs Scabaility

* 성능에 문제가 있는 경우엔, 단일 사용자에 대한 응답 속도가 느려진다.
* 확장성에 문제가 있는 경우엔, 당장은 단일 사용자에게는 빠르지만 부하가 많아질 경우 속도가 느려질 수 있다.

### 3.3. 시간

* 사용자에게 있어 Time은 응답 시간만 존재한다.
  * 그러나 실제 시스템 입장에선, 사용자가 요청에 대해 응답을 받은 후에 웹 페이지를 보는 등의 작업을 하는 Think Time이 존재한다.
* 성능 테스트 시엔 실제 지연 시간이 발생하는 구간을 파악해야 한다.
  * 브라우저와 웹 서버간 구간에서는 정적 파일 크기, Connection 관리, 네트워크 환경 등의 영향을 받을 수 있다.
* Server 구간에서 발생한 경우, DB-APP 연결 문제나 프로그램 로직 상의 문제 혹은 서버의 리소스 부족 등을 의심해 볼 수 있다.
* 네트워크 이슈의 경우 테스트하는 환경에 따라 달라질 수도 있다.
  * 지연 현상은 사용자의 이탈과 매우 밀접하기에 개선되어야 하지만, 단순히 Scale Out한다고 해결되는 것은 아니다.
  * 출시 전에 테스트를 하여 최대 응답시간을 파악하고 있어야 하며, 상위 5%의 화면이 95% 사용자 요청을 받는다는 점을 감안하고 튜닝의 대상을 선정해야 한다.

<br>

## 4. 성능 테스트

* 목적
  * 각 시스템의 응답 성능 및 한계치를 알 수 있다.
  * 부하가 많이 발생할 때 나타나는 증상을 확인하고 성능을 개선할 수 있다.
  * 서비스가 확장성을 가졌는지 확인할 수 있다.

### 4.1. 종류

* Smoke Test
  * 최소한의 부하로 구성된 테스트로, 테스트 시나리오에 오류가 없는지 확인할 수 있다.
  * 최소 부하 상태에서 시스템에 오류가 발생하지 않는지 확인할 수 있다.
  * VUser를 1 ~ 2로 구성한다.
* Load Test
  * 서비스의 평소 트래픽과 최대 트래픽 상황에서의 성능 및 기능의 정상 작동 유무를 확인한다.
  * 애플리케이션 배포 및 인프라 변경시에 성능 변화를 확인한다.
  * 외부 요인(결제 API 등)에 따른 예외 상황을 확인한다.
* Stress Test
  * 서비스가 극한의 상황에서 어떻게 동작하는지 확인한다.
  * 장기간 부하 발생에 대한 한계치를 확인하고 기능이 정상 동작하는지 확인한다.
  * 최대 사용자 또는 최대 처리량을 확인한다.
  * 테스트 이후 시스템이 수동 개입없이 복구되는지 확인한다.

### 4.2. 주의사항

* 실제 사용자가 접속하는 환경에서 성능 테스트를 진행해야 한다.
  * 내부 네트워크에서 부하를 발생시키면 응답 시간 차이가 존재할 수 있다.
* 부하 테스트는 클라이언트 내부 처리시간이 배제되어있다.
* 테스트 DB에 들어있는 데이터의 양이 실제 운영 DB와 동일해야 한다.
  * 전체 성능의 70% 이상이 DB에 좌우되며, 데이터 양이 다르면 쿼리의 실행 계획이 달라진다.
  * 데이터가 소량이면 디스크 입출력이 발생하지 않고, 메모리에 로드되어 성능이 빠른 것으로 착각할 수 있다.
* 운영 환경의 경우, 서비스 요청 외에 별도로 수행되는 배치나 후속 작업으로 인한 부하가 존재하면 이들 또한 테스트 시나리오에 포함해야 한다.
* 외부 요인(결제 등)의 경우 시스템과 분리된 별도의 서버로 구성해야 한다.
  * 객체를 Mocking하는 경우 Http Connection Pool, Connection Thread 등을 사용하지 않아 IO가 발생하지 않는다.
  * 같은 어플리케이션에 Dummy Controller를 구성하는 경우 테스트 시스템의 자원과 리소스를 같이 사용하므로 테스트의 신뢰성이 떨어진다.

<br>

## 5. 테스트 계획

### 5.1. 전제 조건

* 테스트하려는 Target 시스템의 범위를 정한다.
* 부하 테스트시 저장될 데이터 건수 및 크기를 결정한다.
  * 서비스 이용자 수, 사용자의 행동 패턴, 사용 기간 등을 고려한다.
* 목푯값에 대한 성능 유지 기간을 정한다.
* 서버에 같이 동작하고 있는 다른 시스템 및 제약 사항 등을 파악한다.

### 5.2. 목푯값 설정

* 예상 1일 사용자 수(DAU)를 정한다.
* 피크 시간대의 집중률(최대 트개픽 / 평소 트래픽)을 예상해본다.
* 1명당 1일 평균 접속 혹은 요청 수를 예상한다.
* 해당 정보를 바탕으로 Throughput을 계산한다.
  * Throughput : 1일 평균 rps ~ 1일 최대 rps
    * 1일 사용자 수(DAU) x 1명당 1일 평균 접속 수 = 1일 총 접속 수
    * 1일 총 접속 수 / 86,400 (초/일) = 1일 평균 rps
    * 1일 평균 rps x (최대 트래픽 / 평소 트래픽) = 1일 최대 rps
  * Latency : 일반적으로 50 ~ 100ms 이하로 잡는다.
  * 사용자가 검색하는 데이터의 양, 갱신하는 데이터의 양 등을 파악해둔다.

### 5.3. VUser 도출 공식

* Request Rate: measured by the number of requests per second (RPS)
* VU: the number of virtual users
* R: the number of requests per VU iteration
* T: a value larger than the time needed to complete a VU iteration

```
T = (R * http_req_duration) (+ 1s) ; 내부망에서 테스트할 경우 예상 latency를 추가한다

VUser = (목표 rps * T) / R
```

### 5.4. 시나리오 대상

* 접속 빈도가 높은 기능
  * 홈페이지
* 서버 리소스 소비량이 높은 기능
  * CPU
    * 이미지, 동영상 변환
    * 인증
    * 파일 압축/해제
  * Network
    * 응답 컨텐츠 크기가 큰 페이지
    * 이미지, 동영상 업로드/다운로드
  * Disk
    * 로그가 많은 페이지
* DB를 사용하는 기능
  * 많은 리소스를 조합하여 결과를 보여주는 페이지
  * 여러 사용자가 같은 리소스를 갱신하는 페이지
* 외부 시스템과 통신하는 기능
  * 결제 기능
  * 알림 기능
  * 인증/인가

<br>

---

## References

* 우아한테크코스
