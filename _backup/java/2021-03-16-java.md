---
title: "Java 특장점 용어 사전"
excerpt: "Java 언어의 특장점 등을 정리한다."
categories:
  - Java
tags:
  - Java
date: 2021-03-17
last_modified_at: 2021-03-17
---

## 1. Java

Java는 썬 마이크로시스템즈의 제임스 고슬링(James Gosling)과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 처음에는 가전 제품 내에 탑재해 동작하는 프로그램을 위해 개발했지만 현재 웹 애플리케이션 개발에 가장 많이 사용하는 언어 가운데 하나이다. 모바일 기기용 소프트웨어 개발에도 널리 사용하고 있다.

<br>

## 2. 장단점

### 2.1. 장점

1. **운영체제에 독립적이다.**
  * JVM에서 동작하기 때문에, 특정 OS에 종속되지 않는다.
2. **객체지향 언어이다.**
  * 객체지향적으로 프로그래밍 하기 위해 추상화 및 다형성 등 여러 언어적 지원을 한다.
3. **자동으로 메모리 관리를 해준다.**
  * JVM에서 데몬 쓰레드인 GC(Garbage Collection)가 발생함으로써, 별도의 메모리 관리 없이 비즈니스 로직에 집중할 수 있다.
4. **오픈소스이다.**
  * OracleJDK와 다르게 OpenJDK는 무료다.
  * 생태계가 잘 구축되어 있다.
5. **멀티스레드를 쉽게 구현할 수 있다.**
  * 스레드 생성 및 제어와 관련된 라이브러리를 제공하고 있기 때문에 OS에 상관없이 멀티 스레드를 쉽게 구현할 수 있다.
6. **동적 로딩(Dynamic Loading)을 지원한다.**
  * 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성한다.
  * 쉽고 빠른 유지보수 : 수정이 필요한 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다.

### 2.2. 단점

1. **비교적 속도가 느리다.**
  * 한 번의 컴파일로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에 C나 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다는 속도가 느리다.
  * 하드웨어의 성능 향상과 바이트 코드를 기계어로 변환해주는 JIT 컴파일러 같은 기술 적용으로 JVM의 기능이 향상되어 속도의 격차가 많이 줄어들었다.
2. **예외처리가 불편하다.**
  * 프로그래머 검사가 필요한 예외가 등장한다면 무조건 프로그래머가 선언을 해줘야 한다.

<br>

## 3. 데이터 타입

1. 기본 데이터 타입(Primitive Data Type)
  * 기본 타입의 종류는 byte, short, char, int, float, double, boolean이 있다.
    * 정수형 : byte(1), short(2), int(4), long(8)
    * 실수형 : float(4), double(8)
    * 논리형 : boolean(1)
    * 문자형 : char(2)
  * 기본 타입의 크기가 작고 고정적이기 때문에 메모리의 **Stack** 영역에 저장된다.
2. 참조 타입(Reference Data Type)
  * 참조 타입의 종류는 Class, Array, Interface, Enumeration이 있다.
    * 기본형을 제외하고는 모두 참조형이다.
    * new 키워드를 이용하여 인스턴스를 생성하고, 생성된 데이터의 주소를 참조하는 타입이다.
      * String과 배열은 참조 타입과 달리 new 없이 생성이 가능하지만 기본 타입이 아닌 참조 타입이다.
  * 참조 타입의 데이터의 크기가 가변적, 동적이기 때문에 동적으로 관리되는 **Heap** 영역에 저장된다.
    * 더 이상 참조되지 않을 때 GC에 의해 파괴된다.
    * 참조 타입은 값이 저장된 곳의 주소를 저장하는 공간으로 객체의 주소를 저장한다.
3. 변수(Variable)
  * 변수란 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미한다.
  * 저장된 값은 변경될 수 있다.

<br>

## 4. 접근 제어자

* private : 해당 클래스 내부에서만 접근이 가능하다.
* default : 해당 패키지 내에서만 접근이 가능하다.
* protected : 동일 패키지내의 클래스 또는 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능하다.
* public : 어떤 클래스에서라도 접근이 가능하다.

<br>

## 5. Wrapper Class

8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 래퍼 클래스(Wrapper class)라고 한다.

* 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 준다.
* 이러한 래퍼 클래스는 모두 java.lang 패키지에 포함되어 제공된다.

### 5.1. Boxing & Unboxing

* 래퍼 클래스(Wrapper class)는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다.
* 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있다.
* 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 과정을 박싱(Boxing)이라고 한다.
* 래퍼 클래스의 인스턴스에 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정을 언박싱(UnBoxing)이라고 한다.

### 5.2. AutoBoxing & AutoUnBoxing

* JDK 1.5부터는 박싱과 언박싱이 필요한 상황에서 Java 컴파일러가 자동으로 처리해 준다.
* 오토 박싱을 이용하면 ``new`` 키워드를 사용하지 않고도 자동으로 래퍼 인스턴스를 생성할 수 있다.
* 반대로 ``xxxValue()`` 메소드를 사용하지 않고도, 오토 언박싱을 이용하여 인스턴스에 저장된 값을 바로 참조할 수 있다.
* 래퍼 클래스의 비교 연산도 오토 언박싱을 통해 가능해지지만, 인스턴스에 저장된 값의 동등 여부 판단은 ``equals()`` 메소드를 사용해야 한다.
  * 래퍼 클래스도 객체이므로 동등 연산자(``==``)를 사용하게 되면, 두 인스턴스의 주소값을 비교한다.

<br>

## 6. Main 메서드가 Public Static인 이유

Main 메서드는 어플리케이션의 시작 지점(Entry Point)이다.

* Main 메서드가 실행되기 위해서는 JVM 메모리 상에 적재되어야 한다.
* 만약 Main 메서드가 Static이 아닌 인스턴스 메서드라면?
  * 누군가가 호출해줄 때까지 메모리 상에 올라갈 수 없다.
* 시작 지점인 Main 메서드 호출을 위해, 해당 메서드가 정의된 클래스의 인스턴스를 만들어 호출한다는 것은 Main 메서드가 시작 지점이 아니라는 모순이 생긴다.

따라서 Entry Point는 인스턴스 생성 없이 실행할 수 있는 구조여야 한다.

* Static 멤버는 클래스 로딩(프로그램 시작) 시 메모리에 로드되어 인스턴트를 생성하지 않아도 접근이 가능하다.
* Main 메서드의 위치가 어디든 JVM이 접근할 수 있어야 하기 때문에 ``public static``이다.

<br>

## 7. Overriding vs Overloading

* Overloading
  * 두 메서드가 같은 이름을 갖고 있으나 파라미터의 개수 혹은 자료형이 다른 경우를 뜻한다.
  * 파라미터는 같은데 리턴 타입이 다르면 성립되지 않는다.
* Overriding
  * 상위 클래스의 메서드와 이름과 시그니쳐가 같은 함수를 하위 클래스에 재정의하는 것을 의미한다.

<br>

## 8. 동일성 vs 동등성

* 동일성은 두 개의 오브젝트가 완전히 같음을 의미한다.
  * 즉, == 연산자를 통해 같은 메모리 공간을 가리키는지 확인한다.
* 동등성은 두 개의 오브젝트가 같은 정보를 같고 있음을 의미한다.
  * 기본 자료형에 대해서는 적용할 수 없다.
  * ``equals()``를 재정의하거든 ``hashCode()``도 재정의하라.

<br>

## 9. Reflection

Java에서 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩(Dynamic Loading)하여 생성자와 필드 및 메서드 등을 사용할 수 있는 기법이다.

* 클래스의 패키지 정보, 접근 지정자, 수퍼 클래스, 어노테이션 정보 등을 얻을 수 있다.
* 컴파일 타임이 아니라 런타임에 동적으로 특정 클래스의 정보를 객체화를 통해 분석 및 추출해낸다.

#### 왜 사용할까?

* 실행 시간에 다른 클래스를 동적으로 로딩하여 접근할 때.
* 클래스와 멤버 필드 및 메서드 등에 관한 정보를 얻어야할 때.

#### 주의할 점

* 외부에 공개되지 않는 private 멤버도 외부에서 접근 및 조작이 가능해진다.
* 성능 상의 이슈가 존재한다.

<br>

## 10. Annotation

주석처럼 프로그래밍 언어에 영향을 미치지 않으며, 유용한 정보를 제공하는 메타데이터다.

* 설정 정보를 코드에 포함시켜 유지할 수 있다.
* 소스 코드의 로직을 방해하지 않고, 특정 프로그램을 위해 정보를 제공할 수 있다.

#### 용례

* 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공.
* 소프트웨어 개발툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공.
* 런타임 시점에 특정 기능을 실행하도록 정보를 제공.

<br>

## 11. Stream

Stream은 Java 8에 추가된 API다.

* 데이터를 다루는데 자주 사용되는 메소드를 정의한다.
* 컬렉션 타입의 데이터를 Stream 메소드에서 내부 반복을 통해 정렬 및 필터링이 가능하다.

#### 특징

* 병렬 처리에 유리하다.
  * 병렬 처리를 위해 Common Fork Join Pool을 사용한다.
  * 각 스레드가 개별 큐를 가지고 있으며, 놀고 있는 스레드가 있으면 일하는 스레드의 작업을 가져와 수행하여 최적의 성능을 도출한다.
  * 코어의 수가 많을수록, 처리할 데이터 수가 많을수록, 데이터당 처리 시간이 길수록 병렬 처리 성능이 향상된다.
  * 배열 및 ArrayList 사용 시 유리하다.
* Immutable
  * 원본 데이터 변경이 불가능하다.
* Lazy
  * 중간 연산을 여러개 작성 시 모두 합쳐서 진행하고, 합쳐진 연산을 최종 연산에서 한 번에 처리한다.
* 재사용 불가능
  * 최종 연산 완료 후 Stream이 닫히므로 재사용이 불가능하다.
  * 저장된 데이터를 꺼내서 처리하는 용도이지 데이터 저장 목적이 아니기 때문이다.

#### 장점

* 내부 반복을 사용하기 때문에 불필요한 코딩 과정을 줄일 수 있고, 직관적인 코드 가독성이 향상된다.

<br>

## 12. Lambda

메소드를 하나의 식으로 표현한 것을 의미한다.

* 람다는 매개변수로 전달할 수 있고, 메소드 결과로 반환이 가능하다.
* 람다는 함수형 인터페이스를 통해서만 사용이 가능하다.

#### 함수형 인터페이스

* 인터페이스 내에 한 개의 추상 메소드만 정의한 것을 의미한다.
* 외부에서 메소드 호출 시 람다식이나 메소드 참조가 가능하다.
* Java에서 함수를 일급 객체로 사용할 수 없는 단점을 보완한다.
  * 메서드를 파라미터로 전달하지 못하고, 항상 객체를 생성하고 익명함수를 정의해 건내는 Boilerplate 문제가 존재했다.
  * 함수형 프로그래밍 패러다임의 등장에 따라 등장했다.
* 함수형 인터페이스임을 명확히 하기 위해 ``@FunctionalInterface`` 애너테이션을 사용한다.

#### 장점

* 기존에 익명함수로 작성하던 코드를 줄여 간단하게 작성이 가능하다.
  * 가독성이 증가한다.

#### 단점

* 까다로운 재귀 활용 및 디버깅 등.

### 12.1. 컴파일러 플로우

* 익명 함수와는 다르게 컴파일된다.
  * 별도 클래스의 인스턴스를 생성한다.
  * ``invokedynamic``을 사용하여 **Lambda 표현식 구현을 위한 코드 생성을 런타임 시 까지 연기**한다.
* 런타임 시에 어떤 방법으로 객체를 생성할지 결정하는데, 성능 향상을 위한 최적화된 방법을 사용한다.

<br>

## 13. Generics

클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다. 즉, Generics란 데이터의 타입을 일반화한다.

컴파일 타임에 미리 타입 검사를 수행함으로써 다음 장점을 가진다.

* 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다.
* 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.
* 오류는 가능한 컴파일 시점에서 발견하는 것이 좋다.
  * 런타임 시점에서 문제가 일어나는 코드는 원인 코드와 물리적으로 떨어져 있기 때문에 디버깅하기 곤란해진다.

<br>

## 14. Serialization vs Deserialization

직렬화란 Java 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 Java 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터를 변환하는 기술이다.

* JVM의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술이다.
* 직렬화 조건
  * java.io.Serializable 인터페이스를 상속받은 객체
  * 혹은 기본 타입

역직렬화란 바이트로 변환된 데이터를 다시 객체로 변환하는 기술이다.

* 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태의 기술이다.
* 역직렬화 조건
  * 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하며 import 되어 있어야 한다.
  * 직렬화와 역직렬화를 진행하는 시스템이 서로 다를 수 있다는 것을 반드시 고려해야 한다.
  * 직렬화 대상 객체는 동일한 serialVersionUID 를 가지고 있어야 한다.

<br>

---

## References

* [Tech Interview](https://github.com/WeareSoft/tech-interview#7-java)
* Java의 정석 (남궁성 저)
