---
title: "JCF(Java Collection Framework) 기초 정리"
excerpt: "Java에서 제공하는 다양한 자료 구조들을 사용해보자."
categories:
  - Java
tags:
  - Java
date: 2021-03-19
last_modified_at: 2021-03-19
---

## 1. JCF(Java Collection Framework)

![image](https://user-images.githubusercontent.com/56240505/132938503-1aa084d3-dee2-4d44-9e50-b4f619f2ccbe.png)

* Java에서 사용할 수 있는 자료 구조 관련 프레임워크를 의미한다.
* Collection은 순서나 집합적인 저장 공간을 의미한다.

<br>

## 2. List Interface

* 순서가 있는 저장 공간으로, 중복을 허용한다.

### 2.1. ArrayList

* Array 데이터 구조, 즉 단방향 포인터 구조를 가진다.
* 각 데이터에 대한 index를 가지고 있어서 순차 조회 기능 성능이 우수하다.
* 끝단의 인덱스부터 순차적인 데이터 추가 및 삭제하는 경우 빠르다.
* 비 순차적으로 배열의 중간에 데이터의 삽입 및 삭제가 빈번하면 성능이 저하된다.
  * 특정 인덱스를 제거하면 해당 공간을 채우기 위해 뒤에 있던 데이터들이 복사되어 앞으로 이동하는 연산이 추가된다.
  * 특정 인덱스에 데이터를 추가하면, 해당 인덱스 기준으로 뒷편의 데이터들을 복사해 뒤로 밀어주는 연산이 추가된다.
* 동기화가 보장되지 않는다.

### 2.2. LinkedList

* 노드(데이터와 링크를 거는 필드)와 노드로 이루어져 있는 연결 리스트다.
* LinkedList의 각 요소에는 LinkedList의 다음 요소에 대한 참조(주소 혹은 포인터)가 있는, 양방향 포인터 구조다.
* 참조를 통해 서로 연결된다.
* ArrayList보다 조회 성능이 떨어지고 많은 메모리를 차지한다.
* 데이터의 삽입 및 삭제가 빈번한 경우, 데이터의 위치 정보만 수정하면 되기 때문에 ArrayList보다 효율적이다.
* **Queue 관련 인터페이스들의 구현체로도 사용이 가능하다.**

### 2.3. Vector

* 배열을 사용하는 등 ArrayList와 겅의 동일하며, 동기화가 보장된다.
  * 하나의 쓰레드만 벡터의 메소드를 호출할 수 있다.
  * 동기화가 단일 스레드에서는 성능 저하가 있어서 단일 스레드 환경에서는 거의 사용하지 않는다.
* 과거의 코드와 호환을 위해 유지하고 있으며, 가급적 ArrayList를 사용하는 것이 성능 면에서 바람직하다.

#### Stack

* Vector를 확장한 클래스다.
* 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO 형식의 자료 구조다.
* 그러나 Stack 대신 ArrayDeque를 사용하는 것이 성능상 유리하다.

<br>

## 3. Queue Interface

* 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out)구조로 저장하는 자료 구조다.
* 한쪽 끝에서는 삽입 연산만 이루어지며 다른 한쪽 끝에서는 삭제 연산만 이루어지는 유한 순서 리스트다.
* 데이터의 삽입 및 삭제가 빈번하기 때문에 LinkedList를 구현체로 제공하지만, **ArrayDeque**를 사용하는 것이 성능상 유리하다.

### 3.1. Priority Queue

* 들어간 순서에 상관 없이 우선순위에 따라 먼저 나오는 자료 구조 구현체다.

### 3.2. Deque

* Deque란 Double-Ended Queue의 줄임말로 큐의 양쪽에서 데이터를 삽입과 삭제를 할 수 있는 자료구조를 의미한다.
* Deque 인터페이스는 Queue 인터페이스를 확장한다.
* 따라서 LinkedList를 구현체로 사용할 수 있다.

#### ArrayDeque

* 그러나 ArrayDeque를 Stack처럼 사용하면 Stack보다 성능이 우수하고, Queue처럼 사용하면 LinkedList보다 성능이 우수하다.
* [해당 글](https://chucoding.tistory.com/52)을 참조하자.
  * 내부적으로 ArrayDeque는 배열을 사용하기 때문에, 빈번한 데이터 추가 및 삭제가 불리한 것 처럼 보인다.
  * 그러나 Queue 특성상 데이터의 삽입 및 삭제가 양 끝단에서 발생하기 때문에, ArrayDeque 또한 LinkedList와 비슷한 시간 복잡도인 O(1)을 가진다.
  * 오히려 조회의 경우 LinkedList에 비해 속도가 빠르며, 다음 참조에 대한 정보가 필요 없어 메모리도 덜 든다.

### 3.3. 그 외

* BlockingDeque
* BlockingQueue
* TransferQueue

<br>

## 4. Set Interface

* 집합적인 저장 공간으로, 중복 허용하지 않는다.

### 4.1. HashSet

* 해시 테이블을 사용해서 Set 인터페이스를 구현한 구현체다.
* 해시 알고리즘을 사용하기 때문에 가장 빠른 임의 접근 속도를 가지며, 저장되는 순서를 예측 할 수 없다.
* 기본적으로 동기화되지 않지만, 명시적으로 동기화 할 수 있다.

### 4.2. LinkedHashSet

* 해시 테이블에서 이중 연결 목록의 구현을 사용한다.
* Set에 삽입되는 데이터의 순서를 보장하고 있는 자료 구조다.

### 4.3. TreeSet

* 이진 검색 트리(BST) 형태로 데이터를 저장하는 구현체다.
* 검색에 뛰어난 성능을 보이며, BST의 성능을 향상시킨 레드-블랙 트리로 구현되어 있다.
  * 자동 정렬 되어 있다.

<br>

## 5. Map Interface

![image](https://user-images.githubusercontent.com/56240505/132938518-b6afe9be-a99c-43a5-b7f5-40cc3bc7e3dc.png)

* Key, Value를 하나의 데이터(Entry)로 저장하는 자료 구조를 의미한다.

### 5.1. HashTable

* HashMap보다는 느리지만 동기화를 지원하며, HashMap과 달리 Value에 null을 허용하지 않는다.

### 5.2. HashMap

* 삽입, 삭제, 검색이 평균적으로 O(1)이다.
* 중복을 허용하지 않고 순서를 보장하지 않는다.
* 동기화되지 않고 키와 값으로 null을 허용한다.

### 5.3. LinkedHashMap

* Map 에 있는 엔트리들의 연결 리스트를 유지하여 입력한 순서대로 반복 가능하다.

### 5.4. TreeMap

* 키 값이 자연 순서 대로 오름차순 정렬되어 Key-Value 쌍으로 저장된다.
* 정렬되었기 때문에 검색이 빠르다.
  * 정렬 때문에 저장 시간이 다소 오래 걸린다.

<br>

## 6. Hash?

![image](https://user-images.githubusercontent.com/56240505/132938677-6b0d264e-16c8-4743-b2bb-2d6735157408.png)

* 키를 해시 함수로 계산하여 그 값을 배열의 인덱스로 사용한다.
  * 해당 인덱스에 값을 저장해둔다.
* 배열의 인덱스(index)를 사용해서 검색, 삽입, 삭제가 빠르다.

<br>

---

## References

* [Java Collections Framework](https://parkho79.tistory.com/99)
