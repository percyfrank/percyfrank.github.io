---
title: "[Modern Java in Action] 18장. 함수형 관점으로 생각하기"
excerpt: "참조적으로 투명한 함수란 같은 인자로 함수를 호출 했을 때 항상 같은 결과를 반환하는 함수이다."
categories:
  - Java
tags:
  - Java
  - Modern Java in Action
date: 2021-03-13
last_modified_at: 2021-03-13
---

## 1. 시스템 구현과 유지보수

프로그램이 시스템의 구조를 이해하기 쉬운 클래스 계층으로 반영한다면 유지보수하기 용이하다. 프로그램의 구조를 평가할 때 다음의 기준을 사용할 수 있다.

* 결합도 : 시스템의 각 부분의 상호 의존성을 의미한다.
* 응집성 : 시스템의 다양한 부분이 서로 어떤 관계를 갖는지 의미한다.

함수형 프로그래밍이 제공하는 **불변성**과 **부작용 없음** 개념이 디버깅을 포함한 시스템의 유지보수에 큰 도움을 준다.

### 1.1. 부작용 없음

부작용이란 함수 내에 포함되지 못한 기능을 의미한다. 다음은 대표적인 부작용의 예이다.

* 예외 발생.
* I/O 수행.
* 컬렉션을 수정하거나 필드에 setter로 값을 할당.

자신을 포함한 클래스의 상태 및 다른 객체의 상태를 바꾸지 않으며 return을 통해 자신의 결과를 반환하는 메서드를 순수 메서드 혹은 부작용 없는 메서드라고 한다. 불변 객체는 가변 상태를 가지지 않아 부작용이 없다.

### 1.2. 선언형 프로그래밍

명령헝 프로그래밍이란 문제 해결을 위해 How에 집중하는 방식이다. 조건문과 반복문(외부 순회) 등을 통해 작성하는 명령어가 컴퓨터의 저수준 언어와 유사하다.

반면 선언형 프로그래밍이란 What에 초점을 맞춘 방식으로서, 대표적으로 Stream API(내부 순회)를 통한 질의문 코드가 있다. 질의문 자체로 개발자가 원하는 것이 무엇이며 어떻게 해당 목표를 달성할지 등의 규칙을 명확하게 보여준다.

함수형 프로그래밍은 선언형 프로그래밍을 따르는 방식으로서 부작용이 없는 계산을 지향한다. 이 방식을 통해 복잡한 질의를 자연스럽게 읽고 쓸 수 있는 코드로 구현할 수 있다.

<br>

## 2. 함수형 프로그래밍이란?

함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 부작용이 없어야 한다. 외부 가변 변수를 수정할 수 있는 메서드는 부작용이 있어 함수라고 볼 수 없다. **함수형**은 수학의 함수처럼 부작용이 없음을 의미한다.

### 2.1. 함수형 Java

Java에서 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 따라서 순수 함수형이 아닌 함수형 프로그램을 구현한다. 실제로는 부작용이 있더라도 외부 호출자가 이를 보지 못하게 함으로써 함수형을 달성할 수 있다.

* 함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다.
  * 참조하는 객체가 있다면 반드시 불변 객체이어야 한다.
    * 객체의 모든 필드는 final이며 모든 참조 필드는 불변 객체를 직접 참조해야 한다.
* 함수형이라면 함수나 메서드가 어떤 예외도 발생시켜서는 안 된다.
  * 예외가 발생하면 return으로 연산 결과를 반환할 수 없어 큰 제약이 된다.
  * 예외를 사용하지 않고 값을 도출하기 위해 Optional을 사용할 수 있다.
  * 예외를 지역적으로만 사용하고 상위 인터페이스로 노출시키지 않는 방법도 존재한다.
    * 다른 컴포넌트에 영향을 미치지 않도록 구현하면 된다.
* 함수 내에서 생성한 객체의 필드는 갱신할 수 있으나, 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 한다.
  * 또한 이는 다음에 함수를 다시 호출한 결과에 영향을 미치지 않아야 한다.
* 수학에서의 함수는 주어진 인자값에 대응하는 하나의 결과만을 반환하지만, 대부분의 수학 연산은 부분 함수로 활용된다.
  * 숫자를 0으로 나누거나 음수의 제곱근 등 연산의 결과가 정의되지 않은 케이스가 존재하기 때문이다.
* 함수나 메서드는 비 함수형 동작을 감출 수 있는 상황에서만 부작용이 존재하는 라이브러리 함수를 사용해야 한다.
  * 두 개의 리스트를 합치는 경우, 부작용이 있는 ``List.add()`` 호출 전에 리스트를 미리 복사해서 내부적으로 적절히 처리한다.

### 2.2. 참조 투명성

**부작용을 감춘다**는 제약은 참조 투명성이라는 개념으로 귀결된다. 참조적으로 투명한 함수란 같은 인자로 함수를 호출 했을 때 항상 같은 결과를 반환하는 함수이다.

* ``Random.nextInt()`` 및 ``Scanner.nextLine()``은 항상 같은 결과가 반환되지 않기 때문에 참조적으로 투명한 함수가 아니다.
* 참조 투명성은 비싸거나 오래 걸리는 연산에 대해 캐싱을 적용하여 성능을 최적화하는 기능을 제공한다.
* List를 반환하는 메서드를 두 번 호출했을 때 결과로 같은 원소를 포함하지만 주솟값이 다른 리스트가 반환되는 경우?
  * 결과 리스트가 가변 객체라면 해당 메서드는 참조적으로 투명하지 않은 함수이다.
  * 결과 리스트가 불변 객체라면 두 리스트의 참조 투명성이 보장된다.
    * 함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다.

### 2.3. 실습

Java 8은 함수형 프로그래밍을 극단적인 OOP의 일종으로 간주한다.

* 극단적인 OOP란 모든 것이 객체이며 프로그램은 객체와 관련된 객체들의 상태를 업데이트하며 동작한다고 간주한다.
  * 반면 함수형 프로그래밍은 가시적인 상태 변화가 없는 참조 투명성을 기반으로 동작한다.
* 개발자들은 함수형 프로그래밍과 극단적인 OOP의 기능을 혼합하여 사용한다.
  * 가변 상태를 지닌 Iterator로 컬렉션을 순회하지만, 해당 가변 상태는 궁극적으로 함수형 스타일로 컬렉션 값들의 합을 계산하는데 사용된다.

> Subset.java

```java
public static <T> List<List<T>> insertAll(T first, List<List<T>> lists) {
    List<List<T>> result = new ArrayList<>();
    for (List<T> l : lists) {
        List<T> copyList = new ArrayList<>();
        copyList.add(first);
        copyList.addAll(l);
        result.add(copyList);
    }
    return result;
}

static <T> List<List<T>> concat(List<List<T>> a, List<List<T>> b) {
    List<List<T>> r = new ArrayList<>(a);
    r.addAll(b);
    return r;
}
```

* 두 메서드는 리스트의 원소들을 미리 복사함으로써 ``List.add()``에서 비롯되는 부작용을 호출자로부터 숨긴다.
* 이를 통해, 두 메서드는 부작용이 없는 순수 함수가 된다.
  * 내부적으로는 가변을 사용할지라도, 인자로 받은 리스트를 수정하지 않은채 결과를 반환한다.

<br>

## 3. 재귀와 반복

순수 함수형 프로그래밍은 반복문을 포함하지 않는다. 반복문을 사용하면 루프의 조건이 변경되는 등 가변이 코드에 포함되기 때문이다.

> Apple.java

```java
Iterator<Apple> it = apples.iterator();
while (it.hasNext()) {
    Apple apple = it.next();
    //...
}
```

* for-each 반복문은 사실 가변 상태를 지닌 Iterator로 디코딩된다.
* 물론 외부 호출자가 볼 수 없다면 지역 변수를 가변시키는 것은 함수형 프로그래밍에서 용납된다.

> Gold.java

```java
public void searchForGold(List<String> l, Stats stats){
    for (String s: l) {
        if ("gold".equals(s)) {
            stats.incrementFor("gold");
        }
    }
}
```

* 프로그램의 다른 부분과 공유하는 Stats 객체를 가변시키기 때문에 해당 메서드는 부작용을 가지고 있다.

> Factorial.java

```java
static long factorialRecursive(long n) {
    return n == 1 ? 1 : n * factorialRecursive(n-1);
}
```

* 가변 상태를 사용하지 않는 재귀를 통해 반복문을 대체할 수 있다.
  * 때론 재귀가 반복문보다 더 직관적이고 가독성이 좋을 수 있다.
* 문제는 재귀 함수가 호출될 때마다 콜 스택에 새로운 개별 스택 프레임이 쌓이게 된다.
  * 새로운 스택 프레임에는 호출된 메서드의 매개변수, 결과값, 리턴됐을 때 돌아갈 위치 등이 저장된다.
  * 재귀 함수는 함수가 끝나지 않은채 연속적으로 함수를 호출하기 때문에 스택에 메모리가 계속 쌓이게 된다.
    * 잦은 점프의 반복으로 인해 성능이 저하되며, 심각한 경우 스택 오버 플로우가 발생한다.

### 3.1. 꼬리 재귀 최적화

꼬리 재귀는 재귀 호출이 끝난 후 현재 함수에서 추가 연산을 요구하지 않도록 구현하는 재귀의 형태다. 이를 통해 기존의 재귀 방식을 최적화할 수 있다.

> TailRecursionFactorial.java

```java
static long factorialTailRecursive(long n) {
    return factorialHelper(1, n);
}

static long factorialHelper(long acc, long n) {
    return n == 1 ? acc : factorialHelper(acc * n, n-1);
}
```

* 일반적인 재귀 방식을 이용한 ``factorialRecursive()``는 재귀 호출이 끝난 후 추가적인 연산(곱셈)이 필요하다.
* 꼬리 재귀 방식을 이용한 ``factorialHelper()``는 별도의 추가 연산 없이 재귀 호출 자체가 마지막 연산이다.
  * 컴파일러는 기존 재귀 호출의 스택이 깊어지는 문제를 선형적으로 처리하도록 알고리즘을 바꿔 하나의 스택 프레임을 재사용할 수 있게 된다.
  * 중간 연산 결과들이 함수의 인자로 직접적으로 전달되기 때문에, 재귀 함수의 중간 연산 결과를 개별 스택 프레임에 저장하여 추적할 필요가 없어진다.
* Java 컴파일러는 꼬리 재귀 최적화를 지원하지 않으나 Scala 등 모던 JVM 언어는 이를 지원한다.
* 반복 대신 스트림 혹은 재귀를 사용함으로써 변화를 피하고 부작용을 없앨 수 있다.

<br>

---

## Reference

* Modern Java in Action(Raoul-Gabriel Urma 저)
