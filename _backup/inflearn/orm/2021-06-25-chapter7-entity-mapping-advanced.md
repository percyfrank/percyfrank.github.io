---
title: "[Java ORM 표준 JPA 프로그래밍] 7장 : 고급 매핑"
excerpt: "Inflearn 김영한님 강의를 참고하여 정리한 필기입니다."
categories:
  - Spring Data
tags:
  - Spring Data
  - Java ORM 표준 JPA 프로그래밍
date: 2021-06-25
last_modified_at: 2021-06-25
---

## 1. 상속 관계 맵핑

* RDB는 상속 관계가 없으나, 슈퍼 타입 및 서브 타입 관계라는 모델링 기법으로 객체 상속과 유사하게 표현할 수 있다.
* 즉, 상속 관계 맵핑이란 객체의 상속 구조와 DB의 슈퍼-서브 타입 관계를 맵핑하는 것이다.
  * 슈퍼-서브 타입 논리 모델을 실제 물리 모델로 구현하는 방법이다.

<br>

## 2. Join 전략

![image](https://user-images.githubusercontent.com/56240505/123434260-3e1af000-d607-11eb-882c-7f030bfca92f.png)

> Item.java

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn
public class Item {

    @Id
    @GeneratedValue
    private Long id;
    private String name;
    private Long price;
}
```

* Join 전략시 ID가 PK이자 FK다.

> Album.java

```java
@Entity
@DiscriminatorValue("A")
public class Album extends Item {

    private String artist;
}
```

> SQL

```sql
create table Album (
   artist varchar(255),
    id bigint not null,
    primary key (id)
)

create table Item (
   id bigint generated by default as identity,
    name varchar(255),
    price bigint,
    primary key (id)
)

create table Movie (
   actor varchar(255),
    director varchar(255),
    id bigint not null,
    primary key (id)
)

alter table Album
    add constraint FKcve1ph6vw9ihye8rbk26h5jm9
    foreign key (id)
    references Item

alter table Movie
    add constraint FK5sq6d5agrc34ithpdfs0umo9g
    foreign key (id)
    references Item
```

* @DiscriminatorColumn를 넣으면 DTYPE 칼럼이 추가된다.
  * 조회 쿼리를 날려보면 각각의 로우에 대해 어떤 자식 테이블인지 DTYPE에 명시되어 있다.
  * 필수는 아니지만 운영시 참고하기 좋다.
* 싱글 테이블이라면 DTYPE이 데이터 타입을 구분할 수 있는 유일한 조건이기에 필수다.
  * 싱글 테이블 전략시 @DiscriminatorColumn 애너테이션이 없더라도 자동으로 생성한다.
* DTYPE에 들어가는 자식 테이블 타입 값을 바꾸려면 자식 테이블에 @DiscriminatorValue를 지정해준다.

### 2.1. 장단점

* 장점
  * 테이블 정규화가 가능하다.
  * FK 참조 무결성 제약 조건 활용이 가능하다.
    * 슈퍼-서브 타입간 무결성이 지켜지므로, ID를 가지고 가격 정산시 자식 테이블 볼 필요 없이 Item 테이블에 존재하는 가격 칼럼만을 사용한다.
  * 저장 공간 효율화가 가능하다.
* 단점
  * 조회시 Join을 많이 사용하며 성능 저하가 유발될 수 있다.
  * 데이터 저장시 Insert 쿼리가 부모 테이블과 자식 테이블 등 총합 2번 호출된다.

<br>

## 3. 단일 테이블 전략

![image](https://user-images.githubusercontent.com/56240505/123434892-ef218a80-d607-11eb-8bd2-216f41325a68.png)

> Item.java

```java
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
```

> SQL

```sql
create table Item (
    DTYPE varchar(31) not null,
    id bigint generated by default as identity,
    name varchar(255),
    price bigint,
    actor varchar(255),
    director varchar(255),
    artist varchar(255),
    primary key (id)
)
```

* @Inheritance를 지정하지 않으면 JPA는 기본적으로 상속 관계를 단일 테이블로 표현해준다.
* 장점
  * 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.
  * 조회 쿼리가 단순하다.
* 단점
  * 자식 엔티티가 맵핑한 컬럼들은 모두 null을 허용해야 한다.
  * 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다.
  * 상황에 따라 조회 성능이 오히려 느려질 수 있다.
* JDBC에서 상속 관계 맵핑 전략을 변경한다면 관련 SQL이 다 변경되어야 하지만, JPA는 애너테이션 설정만 변경하면 된다.  

<br>

## 3. 구현 클래스마다 테이블 전략

![image](https://user-images.githubusercontent.com/56240505/123435299-63f4c480-d608-11eb-84a2-1abc7437ed04.png)

* 이 전략은 추천하지 않는다.
* 해당 전략일 경우 Item은 추상 클래스여야 Item 테이블이 생성되지 않는다.
  * 나머지 전략은 추상이든 구체든 상관하지 않는 것으로 보인다.
* 장점
  * 서브 타입을 명확하게 구분해서 처리할 때 효과적이다.
  * not null 제약 조건 사용이 가능하다.
* 단점
  * 자식 테이블을 통합해서 쿼리하기 어렵다.

> Application.java

```java
Item find = entityManager.find(Item.class, movie.getId());
```

> SQL

```sql
select
    item0_.id as id1_1_0_,
    item0_.name as name2_1_0_,
    item0_.price as price3_1_0_,
    item0_.actor as actor1_2_0_,
    item0_.director as director2_2_0_,
    item0_.artist as artist1_0_0_,
    item0_.clazz_ as clazz_0_
from
    ( select
        id,
        name,
        price,
        actor,
        director,
        null as artist,
        1 as clazz_
    from
        Movie
    union
    all select
        id,
        name,
        price,
        null as actor,
        null as director,
        artist,
        2 as clazz_
    from
        Album
) item0_
where
item0_.id=?
```

* JPA로 엔티티 조회시 타입을 부모 타입으로 지정하면, 부모 타입의 자식 테이블에 해당하는 모든 테이블들을 UNION하여 조회한다.
  * 성능이 심각하게 떨어진다.

<br>

## 4. @MappedSuperclass

* 상속 관계 맵핑이 아니며, 특정 엔티티나 테이블과 맵핑되지 않는다.
* 부모 클래스를 상속받는 자식 클래스에 맵핑 정보만 제공한다.
* 수퍼 클래스 타입으로 조회 및 검색이 불가능하다.
* 직접 생성해서 사용할 일이 없기에 추상 클래스를 권장한다.
* 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할이다.
  * 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용한다.
* **@Entity 클래스는 다른 @Entity나 @MappedSuperclass를 지정한 클래스만 상속이 가능하다.**

> BaseEntity.java

```java
@MappedSuperclass
public class BaseEntity {

    private String createdBy;
    private LocalDateTime createDate;
    private String lastModifiedBy;
    private LocalDateTime lastModifiedDate;
}
```

> Member.java

```java
@Entity
public class Member extends BaseEntity {
    //...
}
```

> SQL

```sql
create table Member (
   id bigint not null,
    createDate timestamp,
    createdBy varchar(255),
    lastModifiedBy varchar(255),
    lastModifiedDate timestamp,
    name varchar(255),
    primary key (id)
)
```

* BaseEntity 테이블은 생성되지 않고 속성만 내려준다.

> Application.java

```java
BaseEntity find = entityManager.find(BaseEntity.class, member.getId());
```

* 위 처럼은 조회할 수 없다.
* **N:N 맵핑을 통해 자동으로 생성되는 중간 테이블에는 BaseEntity의 속성이 추가되지 않는다.**
  * 따라서 다대다 연관 관계를 만들지 말고, 1:N과 N:1로 분리할 수 있는 별도의 중간 연결 테이블을 만든다.

<br>

---

## References

*	자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한, Inflearn)
