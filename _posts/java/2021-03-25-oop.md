---
title: "OOP(Object-Oriented Programming)"
excerpt: "객체지향 프로그래밍이란?"
categories:
  - Java
tags:
  - Java
date: 2021-03-25
last_modified_at: 2021-03-25
---

## 1. Object

객체는 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것을 의미한다.

* OOP의 객체는 현실 세계의 실체 혹은 개념을 반영하거나 혹은 이를 기반으로 의인화 및 은유된 것으로, 상태와 행위를 가지는 데이터의 집합이다.
* 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다.
* 각 객체는 협력 내에서 정해진 역할을 수행하며, 역할은 관련된 책임의 집합이다.
* 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.

<br>

## 2. OOP(Object-Oriented Programming)

객체지향 프로그래밍이란 **각자의 역할 및 책임을 지닌 객체들끼리 서로 메시지를 주고 받는 등 상호 협력을 통해 어플리케이션이 동작한다**는 관점에서 프로그래밍하는 것을 의미한다. 객체지향 프로그램에서 객체들은 주어진 역할 및 책임을 자율적으로 수행하고, 시스템의 행위를 구현하기 위해 다른 객체들과 협력한다.

### 2.1. 절차적 프로그래밍(Procedure Programming)

> 절차 지향 프로그래밍이라는 단어는 존재하지 않는다. 모든 프로그래밍 언어는 절차적이다. 다만 OOP 언어를 가지고 OOP 특장점을 살리지 않는다면 절차적 프로그래밍이라고 할 수 있겠다.

단순히 순차적인 명령 수행이 아니라 프로시저(루틴, 서브루틴, 메소드, 함수 등)를 이용한 프로그래밍 패러다임이다.

* 데이터와 함수를 별개로 취급한다.
* 데이터를 중심으로 프로시저를 구현하고, 목적을 달성하기 위해 유기적으로 연결된 함수의 실행 순서 및 절차를 보다 중시한다.
  * 객체지향은 데이터와 프로시저를 클래스(객체)로 그룹화하고, 목적을 달성하기 위해 객체간의 상호 협력을 중시한다는 차이가 있다.

#### 장점

* 필요한 기능을 함수로 정의해둠으로써 코드의 재사용 및 모듈화가 가능하다.
* 컴퓨터의 처리 구조와 유사해서 실행 속도가 빠르다.

#### 단점

* 소프트웨어 규모가 커지고 복잡해지면서 순서 절차가 꼬이면 기대하는 결과값이 나오기 어렵다.
* 코드의 유기성이 높아 유지보수하기 어렵다.

### 2.2 대두 배경

하드웨어의 빠른 발전으로 컴퓨팅 파워가 급속도로 증가했으며, 소프트웨어 역시 이러한 환경에 부응해 규모가 커졌다. 소프트웨어가 복잡해지면서 절차적 프로그래밍으로 작성된 어플리케이션의 유지보수가 힘들어졌는데, 컴퓨팅 파워가 발전된만큼 퍼포먼스가 조금 낮아지더라도 유지보수가 용이하게 작성될 필요가 생겼다.

* 객체 지향은 특정 프로세스의 주요 행위자를 객체로 설정하고, 객체간의 관계에 따라 상태 및 행위(함수)를 작성한다.
  * 데이터와 프로시저를 클래스(객체)로 그룹화하고, 목적을 달성하기 위해 객체간의 상호 협력을 중시한다.

### 2.3. 장단점

#### 장점

1. 모듈화, 캡슐화로 인해 유지보수에 용이하다.
  * 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 가진다.
2. 현실 세계와의 유사성에 의해 코드를 이해하기 쉽게 만든다.
3. 재사용성과 확장성 및 융통성이 높다.
  * 클래스는 객체를 생성하는데 코드가 재사용되며, 상속의 경우 코드 중복을 줄인다.
  * 추상화 등을 통해 연관된 객체들의 코드 변경 없이 내부 구현 혹은 구현체를 자유롭게 변경할 수 있다.

#### 단점

1. 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생하게 된다.
  * 처리속도가 상대적으로 느리다.
2. 객체가 상태를 갖기 때문에 예상치 못한 부작용이 발생할 수 있다.
  * 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킬 수 있다.
  * 불변 객체를 통해 어느 정도 극복이 가능하며, 함수형 프로그래밍 패러다임의 등장이 되었다.

<br>

## 3. Class vs Object vs Instance

1. Class
  * 객체를 만들어 내기 위한 설계도 혹은 틀을 의미한다.
  * 객체는 시간에 따라 동적으로 변화할 수 있지만, 클래스는 객체의 상태를 시간과 무관하게 객체가 가질 수 있는 모든 상태 및 행위를 정적으로 묘사하는 추상화다.
2. Object
  * 소프트웨어 세계에서 구현할 대상이다.
  * 클래스에 선언된 모양 그대로 생성된 실체를 지칭한다.
  * 클래스의 타입으로 선언되었을 때 객체라고 주로 표현하며, 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
3. Instance
  * 클래스를 바탕으로 소프트웨어 세계에서 구현된 구체적인 실체를 의미한다.
  * 객체를 소프트웨어에서 실체화하면 이를 인스턴스로 부른다.
    * 즉, 객체가 메모리에 할당되어 실제 사용될 때 주로 인스턴스라고 칭한다.
  * 인스턴스는 객체에 포함되는 개념이다.

<br>

## 4. 특징

1. 캡슐화
  * 데이터와 기능을 클래스라는 틀에 정의하고, 외부에서 클래스 내부 구현 내용에 대해 마음대로 접근할 수 없는 등 은폐되는 것을 의미한다.
  * 절차지향 프로그래밍에서는 소스 코드가 거대해질수록 데이터가 어디서 어떻게 변화하는지 파악하기 어려웠고 유지보수가 힘들었다.
  * 객체지향 프로그래밍에서는 내부의 데이터나 함수를 외부에서 외부에서 참조하지 못해 이러한 에러 발생 가능성을 낮춘다.
2. 상속
  * 부모의 형질을 이어받는다는 의미로, 부모 클래스의 속성과 메소드를 그대로 활용할 수 있다.
  * 여기에 더해 새로운 속성과 메소드를 추가할 수 있으며 같은 메소드라 하더라도 오버라이딩(Overriding)을 통하여 재정의하여 다르게 동작하게끔 할 수 있다.
  * 손쉽게 클래스를 재활용할 수 있으며, 부모가 같은 클래스들을 동시에 처리하기 용이하다.
3. 추상화
  * 객체에서 공통된 속성이나 기능을 추출하는 것이다.
  * 불필요한 부분은 생략하고, 객체들의 속성 및 행위들 중 중요한 부분을 강조하여 추출 및 모델화하는 것이다.
  * 주요 관심사에만 집중함으로써, 프로그램의 복잡도를 관리할 수 있다.
  * 데이터들의 공통 성질을 추출하여 슈퍼 클래스를 선정한다.
4. 다형성
  * 서로 다른 타입에 속한 객체들이 동일 메시지를 수신한 경우, 서로 다른 메서드(서로 다른 세부 구현)에 따라 상이하게 메시지를 처리할 수 있는 메커니즘이다.
    * 이를 위해 객체들이 동일한 책임 및 역할(상위 공통 인터페이스 혹은 상속 부모 클래스) 등을 공유해야 한다.
    * 동일 역할을 공유하는 객체들간 대체 가능성이 존재한다.
    * 메시지 송신자는 수신자의 종류를 몰라도 메시지 전송이 가능하며, 다형성으로 수신자의 종류를 캡슐화할 수 있다.
  * Overriding

<br>

---

## References

* [객체지향의 사실과 오해](https://xlffm3.github.io/book/oop-truth-misunderstanding/)
