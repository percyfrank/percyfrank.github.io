---
title: "JVM(Java Virtual Machine)"
excerpt: "인간이 작성한 Java 코드가 실행되는 원리를 알아보자."
categories:
  - Java
tags:
  - Java
date: 2021-03-18
last_modified_at: 2021-03-18
---

## 1. Compile

컴파일은 어떤 언어의 코드를 다른 언어의 코드로 변경하는 것을 의미한다. 일반적으로 고급 언어로 작성된 소스 코드를 컴퓨터(OS)가 직접 이해할 수 있는 기계어로 변환해주는 작업을 일컫는다. 컴파일러는 컴파일이라는 일련의 번역 작업을 수행해주는 프로그램이다.

### 1.1. C 언어의 Compile 과정

1. 전처리(Pre-process)
  * 주석을 제거하고 매크로 및 Include 파일들을 인라인화하는 등 컴파일러가 쉽게 인식할 수 있도록 C언어 소스를 재정리한다.
  * 전처리가 끝나면 .c 파일은 .i 파일로 치환된다.
2. 컴파일(Compile)
  * 어휘, 구문, 문법 등을 분석하고 최적화 등의 작업을 수행하면서 최종적으로 어셈블리 코드를 생성한다.
  * 컴파일이 끝나면 .i 파일은 .s 파일로 치환된다.
  * 어셈블리 언어란 사람이 기계를 쉽게 제어하기 위해 고안된 언어로, 기계어와 1:1로 대응되는 저수준 언어다.
3. 어셈블(Assemble)
  * 어셈블러 소스(.s)를 바탕으로 목적 파일(.obj)을 생성한다.
  * 목적 파일은 컴퓨터가 이해할 수 있는 0과 1로 이루어진 바이너리 코드지만 실행이 불가능하다.
    * 완전한 기계어(CPU에서 사용하는 명령어의 집합)가 아니기 때문이다.
  * 바이너리 코드는 기계어와 유사한 레벨의 코드지만, 다음의 과정이 수반되어야 완전한 기계어가 된다.
    * 링커에 의해 메모리 주소값을 반영한다.
    * CPU가 직접 해독하고 실행할 수 있도록 수정된다.
  * 완벽한 기계어는 실행파일 뿐이다.
4. 링크(Link)
  * 링커가 여러 목적 파일(바이너리 코드) 및 사용 라이브러리들을 묶고 연결시켜 하나의 실행 파일을 생성한다.

### 1.2. 기계어

기계어는 0과 1로 이루어진 바이너리 코드다. 기계어가 이진 코드로 이루어졌을 뿐이지 모든 이진 코드가 기계어인 것은 아니다.

* 기계어는 특정한 언어가 아니며, CPU 제조사에서 CPU를 만들 때 해당 CPU에서 사용하는 명령어 집합을 공개하는데 이를 기계어라고 칭한다.
* 따라서 CPU가 변경되면 기계어는 달라진다.
  * 같은 동작을 하는 명령어지만 전혀 다른 0과 1의 나열이 될 수 있다.

### 1.3. Native Code의 단점

Native Code는 Unmanaged Code라고 불리며, 컴파일을 하게 되면 OS에서 바로 해석이 가능한 기계어로 변환된다. OS의 메모리를 동적 할당하는 C가 대표적인 네이티브 언어다. C로 작성된 소스 코드를 컴파일하면 OS가 직접 인식할 수 있는 기계어로 변환되기 때문에 Java같은 Managed Code보다 속도가 빠르다.

그러나 Native Code로 작성한 어플리케이션은 OS 시스템의 자원을 직접 제어하기 위해 OS 바로 위에서 동작하기 때문에 플랫폼(OS)에 종속된다. 같은 프로그램인데도 Windows, Mac, Linux 등 각 OS별로 다르게 작성 및 개발되어야 하는 단점이 있다.

<br>

## 2. JVM(Java Virtual Machine)

> JVM(Java Virtual Machine)은 Java Byte Code를 OS에 맞게 해석해주는 스택 기반의 가상 머신이다.

가상 머신(Virtual Machine)은 컴퓨터 시스템을 에뮬레이션함으로써 컴퓨터 안에서 또 다른 컴퓨터를 동작시키는 것이다. 물리적인 머신과 유사한 머신(컴퓨팅 환경)을 소프트웨어로 구현한 것이다. 크게 시스템 가상 머신과 프로세스 가상 머신으로 나뉜다.

* 시스템 가상 머신은 실제 기계를 대체하며, 전체 운영체제를 실행하기 위한 기능들을 제공한다.
  * 하나의 물리 자원인 컴퓨터 위에 하나의 OS 환경만 있는 것을 효율화하고자, 가상화층을 만들고 그 위에 OS를 새로 설치해 하나의 컴퓨터에서 여러 개의 OS를 실행할 수 있다.
* 프로세스 가상 머신은 플랫폼에 독립적인 환경에서 프로그램을 실행하기 위해 고안되었다.

JVM은 대표적인 프로세스 가상 머신이다. Java Compiler는 인간이 작성한 ``.java`` 소스 파일이 목적 파일 ``.class``로 변환될 때 컴퓨터가 바로 인식할 수 있는 바이너리 코드가 아닌 Java Byte Code로 변환한다. Java Byte Code는 기계어가 아니기 때문에 OS가 바로 실행할 수 없다. 이 때 JVM이 Java Byte Code를 OS가 이해할 수 있도록 Native Code로 해석(Interpret)하고 실행해준다.

![image](https://user-images.githubusercontent.com/56240505/105574872-a9d40500-5daa-11eb-8cbe-63d2fcb76ca2.png)

Java Byte Code는 JVM의 해석 과정을 거치기 때문에 Unmanaged Code보다 속도가 느리지만, JVM 위에서 동작하기 때문에 OS(플랫폼)에 종속적이지 않다는 장점이 있다. Java 프로그램은 JVM에 종속적이다. 각 OS에 맞는 JVM만 존재한다면 Java 어플리케이션은 OS에 상관없이 작동할 수 있다.

### 2.1. Java Byte Code

바이트 코드는 가상 머신이 이해할 수 언어이며, CPU가 아닌 가상 머신에서 실행되는 프로그램을 위한 이진 표현법이다.

* 어떤 플랫폼에도 종속되지 않고 실행될 수 있는 가상 머신용 기계어 코드다.
* 고급 언어로 작성된 소스 코드가 가상 머신이 이해할 수 있는 중간 코드로 컴파일된 것을 의미한다.
* **바이트 코드는 다시 실시간 번역기 또는 JIT 컴파일러를 통해 바이너리 코드로 변환된다.**

<br>

## 3. JRE와 JDK

> 요약하자면 JRE는 읽기 전용, JDK는 읽기 / 쓰기 전용이다.

* JRE(Java Runtime Environment)

컴파일된 Java 프로그램(Java Byte Code)을 실행시킬 수 있는 실행 환경이다. JRE는 JVM이 Java 프로그램을 동작시킬 때 필요한 라이브러리 파일 및 Interpreter(JIT Compiler) 등을 가지고 있다. Java 프로그램을 실행시키기 위해 JRE를 설치해야 한다.

그러나 Java 프로그램(Java Byte Code)을 작성(컴파일)할 Java Compiler 등의 도구가 포함되어 있지 않다.

* JDK(Java Development Kit)

Java 프로그램(Java Byte Code)을 작성(컴파일)하는데 필요한 Java Compiler 등의 도구들을 포함한다. JDK를 설치하면 JRE도 함께 설치된다. JDK = JRE + @이다.

<br>

## 4. JIT Compiler

컴퓨터 프로그램을 만드는 방법은 두 가지가 있다.

1. Static Compile
  * 실행하기 전에 프로그램 코드를 기계어로 모두 번역한다.
  * 런타임 이전에 이미 해석을 마치고 대게 컴파일 결과물이 바로 기계어로 전환되기 때문에 OS 및 빌드 환경에 종속적이다.
  * OS 환경에 맞게 호환되는 라이브러리와 빌드환경을 구분해서 구축해줘야 한다.
  * 구동시에 코드와 함께 시스템으로부터 메모리를 할당받으며, 할당받은 메모리를 사용한다.
  * 상대적으로 높은 퍼포먼스를 보일 수 있다.
2. Interpreter
  * 런타임 이후에 Row 단위로 코드를 해석(Interpret)하며, 해당 기능에 대응하는 기계어 코드를 실행해 프로그램을 구동하는 방식이다.
  * 바로 기계어로 번역하는 것이 아니라 중간 언어인 바이트 코드로 변환한 뒤 런타임에 즉시 해석한다.
  * 런타임에 직접 코드를 구동시키는 특징이 있기 때문에 퍼포먼스가 낮지만, 런타임에 실시간 Debugging 및 코드 수정이 가능하다.
  * 메모리를 별도로 할당받아 수행되지 않으며, 필요할 때 할당하여 사용한다.

![image](https://user-images.githubusercontent.com/56240505/132830438-e0eaabd4-1768-480a-9662-9ed7e160fae8.png)

Interpreter 언어로 작성한 프로그램은 실행 시마다 Interpreter가 소스 코드를 한 줄씩 읽어서 기계어로 번역하는 방식이기 때문에 정적 컴파일을 통해 생성한 프로그램보다 속도가 느리다. Java는 컴파일러와 인터프리터를 모두 사용한다.

Java는 이러한 속도 단점을 극복하기 위해 JVM에 JIT(Just-In-Time) Compiler를 도입했다. JIT 컴파일이란 동적 번역이라고도 부르며, 프로그램을 실제 실행하는 시점(실시간)에 기계어로 번역하는 컴파일 기법이다.

![image](https://user-images.githubusercontent.com/56240505/105577983-5f5d8300-5dc0-11eb-85ce-8a286286cc9b.png)

JIT 컴파일러는 같은 Java Byte Code를 매번 기계어로 번역하는 대신, 처음 실행될 때 성능을 좌우하는(자주 반복되어 사용되는) 코드들을 미리 기계어로 컴파일하여 캐싱해둔다.

* 메소드 영역에 있는 코드 캐시(Code Cache) 공간에 캐싱한다.
* 처음부터 바로 캐싱하는 것은 아니고 누적 호출 횟수 등 컴파일 임계치를 넘으면 컴파일 캐싱한다.
* 이후 해당 중요 코드들이 호출될 때마다, JVM은 이를 매번 기계어로 번역하지 않고 캐싱된 기계어를 바로 실행함으로써 인터프리터 속도 향상을 도모한다.
* 비용 문제로 인해 그 외의 비교적 덜 중요한 코드들은 일반 Interpreter가 실행 시점마다 기계어로 한 줄씩 번역해서 실행한다.

<br>

## 5. JVM의 구조

![image](https://user-images.githubusercontent.com/56240505/105575987-194df280-5db3-11eb-9f21-332c3e2f48ce.png)

### 5.1. Class Loader

JDK에서 개발하고, JRE를 통해서 환경을 제공받은 JVM은 컴파일된 바이트 코드를 탑재하여 로직을 실행하게 된다. Java 프로그램은 런타임시 모든 클래스 파일(바이트 코드)들이 한 번에 JVM에 탑재(메모리에 로딩)되지 않는다. 프로그램에서 특정 클래스 파일이 호출되어 필요한 순간 메모리에 로딩된다.

클래스 로더는 각 디렉터리에 흩어져 있는 클래스 파일들을 찾아 런타임 시점에 동적으로 로딩해준다. 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 인스턴스가 로드된다. **한번 JVM에 탑재된 클래스 파일은 종료될 때까지 JVM에서 제거되지 않는다.**

클래스 로더는 Loading, Linking, Initialization 세 가지 작업을 수행한다.

#### Loading

![image](https://user-images.githubusercontent.com/56240505/132832693-6fe89a20-35cb-458b-af62-2e6f735a78f5.png)

클래스 로더는 클래스 파일이 기본적으로 제공되는 파일인지 개발자가 정의한 파일인지 등에 따라 세 가지 수준으로 나뉜다.

1. Bootstrap ClassLoader
  * 다른 모든 ClassLoader의 부모가 되는 ClassLoader다.
  * rt.jar를 포함하여, JVM을 구동시키기 위한 가장 필수적인 라이브러리의 클래스들을 JVM에 탑재한다.
  * OS에 맞게 네이티브 코드로 쓰여있다.
2. Extensions ClassLoader
  * BootStrap ClassLoader 다음으로 우선 순위를 가진다.
  * localedata, zipfs 등 표준 핵심 Java Class의 라이브러리들을 JVM 에 탑재하는 역할을 한다.
    * $JAVAHOME에 정의된 클래스들이다.
3. Application ClassLoader
  * 개발자들이 정의한 Classpath에 있는 클래스 파일들을 JVM에 탑재한다.

클래스 로딩 과정에서 하위 클래스 로더가 로딩한 클래스 파일은 상위 클래스 로더가 로딩한 클래스 파일을 볼 수 있으나, 반대는 불가능하다. 만약 이 과정에서 클래스를 찾지 못한다면 ClassNotFoundException이 발생한다.

#### Linking

Linking은 로드된 클래스 파일들을 검증하고, 사용할 수 있게 준비하는 과정이다.

1. Verification
  * 클래스 파일이 유효한지를 확인한다.
  * 클래스 파일이 JVM의 구동 조건대로 구현되지 않았다면 VerifyError를 던진다.
2. Preparation
  * 클래스 및 인터페이스에 필요한 static field 메모리를 할당하고, 이를 기본값으로 초기화한다.
  * 기본값으로 초기화된 static field 값들은 뒤의 Initialization 과정에서 코드에 작성한 초기값으로 변경된다.
  * 이 때문에 JVM에 탑재된 클래스 파일의 코드를 작동시키지는 않는다.
3. Resolution
  * Symbolic Reference 값을 JVM의 메모리 구성 요소인 Method Area의 런타임 환경 풀을 통하여 Direct Reference라는 메모리 주소 값으로 바꾼다.
  * 해당 단계의 영향을 받는 JVM Instruction 요소는 new 및 instanceof가 있다.

#### Initialization

* 클래스 파일의 코드를 읽는다.
* Java 코드에서의 class 및 interface의 static field 값들을 지정한 값들로 초기화 및 초기화 메서드를 실행해준다.
* JVM은 멀티 쓰레딩으로 작동을 하며, 같은 시간에 한 번에 초기화를 하는 경우가 있기 때문에 초기화 단계에서도 동시성을 고려해야 한다.
* Class Loader를 통한 클래스 탑재 과정이 끝나면 본격적으로 JVM에서 클래스 파일을 구동시킬 준비가 끝난다.

### 5.2. Runtime Data Areas

![image](https://user-images.githubusercontent.com/56240505/105578747-b6b22200-5dc5-11eb-885f-6ce2beccf6b9.png)

JVM에 탑재된 클래스 파일들이 JVM에서 어떤 메모리 영역을 차지하는지 알아보자.

Runtime Data Area는 JVM이 OS로부터 할당받은 메모리 영역이다. PC Register와 JVM Stack 및 Native Method Stack 등 세 개의 영역은 각 Thread별로 하나씩 생성된다. 반면 Heap과 Method Area 및 Runtime Constant Pool은 모든 Thread가 공유하는 공간으로서 JVM이 실행될 때 생성되며, GC의 관리 대상이다.

#### Method Area(= Class Area = Static Area = Code Area)

클래스가 호출되면 JVM은 해당 클래스 파일(Java Byte Code)을 분석하여 클래스의 인스턴스 변수, 메소드 코드, 생성자 등의 데이터를 Method Area에 저장한다. 이 때 static 키워드가 붙은 전역 클래스 변수도 이 영역에 함께 저장된다.

기초 역할을 하므로 JVM 구동 시작 시에 생성이 되며, 종료 시까지 유지되는 공통 영역이다.

#### Runtime Constant Pool

각 클래스와 인터페이스의 상수뿐만 아니라 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. JVM의 다른 메모리 영역에서 메서드 및 필드 등의 정보에 대한 요청이 오면, JVM은 런타임 상수 풀을 통해 실제 물리 메모리상 주소를 찾아서 변환해 전달한다.

#### Heap

Heap 메모리 영역은 코드 실행을 위한 Java로 구성된 객체 및 JRE 클래스들이 탑재된다. 문자열에 대한 정보를 가진 **String Pool**과 실제 데이터를 가진 인스턴스 및 배열 등이 저장되는 메모리 공간이다.

JVM당 하나만 생성되고, 해당 영역이 가진 데이터는 모든 Java Stack 영역에서 참조되는 등 Thread간 공유가 가능하다. 따라서 해당 영역에 있는 객체나 인스턴스를 사용하려면, synchronized 블록 등을 통해 동시성을 지켜야 한다.

Heap 영역이 가득 차면 OutOfMemoryError를 발생시킨다. Stack에 비해 속도가 조금 느리며, GC 성능 이슈에서 가장 많이 언급되는 공간이다.

![image](https://user-images.githubusercontent.com/56240505/132839321-62d31849-2fb0-462c-bc22-c0ec6cf17a94.png)

* new를 통해 생성된 신생 데이터는 Eden에 위치하며 이후 Survivor로 이동된다.
* 참조되지 않는 인스턴스와 배열 대상으로 Minor GC가 일어난다.
* 가장 주요하게 GC가 일어나는 부분은 Old 부분이다.

#### JVM Stack

JVM은 Stack 기반의 가상 머신이다. 메서드를 호출할 때 마다 Stack Frame이 JVM Stack에 추가(push)되고, 메서드에 사용되는 지역 변수와 리터럴 등의 값들이 해당 Stack Frame에 저장한다. 메서드가 종료되면 JVM Stack에서 해당 Stack Frame이 소멸(pop)된다. Java Stack 영역이 가득 차게 되면 StackOverflowError를 발생시킨다.

Frame은 다음과 같이 구성된다.

* Local Variable : 메소드 내부 지역 변수들을 가지고 있다.
* Operand Stack : 메소드 내 연산을 위해서 바이트 코드 명령문들이 들어있는 공간이다.
* Constant Pool Reference : Constant Pool 참조를 위한 공간이다.

Stack은 Thread 별로 따로 할당되며 Heap 메모리 영역보다 비교적 빠르다. 또한 동시성 문제에서 자유롭다.

#### Native Method Stack

순수한 Java 코드로 사용할 수 없는 시스템의 자원 및 API를 사용하기 위해, 다른 프로그래밍 언어로 작성된 메서드를 사용하는데 이를 Native Method라고 한다.

Native Method Stack은 Java로 작성되지 않은 Native Method를 다루는 영역이다. Byte Code가 아닌 언어를 Byte Code로 전환하여 저장한다.

JVM Stack 영역과 비슷하게 Native Method가 실행될 경우 Stack에 해당 메서드가 쌓인다.

#### PC Register

Thread는 CPU 스케쥴링에 의해 선점되기 때문에 명령어를 연속적으로 수행하지 못한다. 따라서 명령어를 어느 부분까지 수행했는지 등 명령어 주소값을 저장하고 기억할 필요가 있다.

JVM에서 Thread는 각자의 메소드를 실행한다. 이 때, Thread 별로 동시에 실행하는 환경이 보장되어야 하므로 Thread 별로 독립적으로 명령어 주소값을 저장할 공간이 필요하다.

PC Register는 Thread가 명령어의 어느 부분까지 수행했는지 등 Thread가 어떤 부분을 어떤 명령으로 실행해야 할 지에 대해 기록하는 영역이다. 실행했던 메서드가 네이트브하다면 undefined가 기록된다.

### 5.3. Execution Engine

Java Byte Code는 Class Loader를 통해 JVM 내의 Runtime Data Areas에 배치된다. 실행 엔진은 Java Byte Code를 명령어 단위로 읽어서 실행한다. Interpreter와 JIT Compiler가 실행되는 공간이다.

#### GC(Garbage Collection)

![image](https://user-images.githubusercontent.com/56240505/132846739-5088e39e-f90b-4067-ae38-171c66b06db1.png)

GC는 JVM 상에서 더 이상 사용되지 않는 Unreachable 데이터의 메모리 할당을 해제시키는 등 메모리 관리 기능을 수행한다. 자동으로 동작하기 때문에 특별한 경우가 아니면 개발자가 직접 메모리를 관리해줄 필요가 없다. GC가 주로 동작하는 대상은 Heap 영역 내의 객체 중에서 참조되지 않은 데이터다.

* JVM Runtime Area를 root set 이라고 한다.
* reachable이 참조하고 있는 다른 객체 역시 reachable이 된다.
* root set에 의해 참조되고 있지 않은 객체들은 unreachable이 된다.

#### Stop-The-World

GC를 자주 실행시키면 여유 메모리를 많이 확보할 수 있기 때문에 성능이 좋아질 것이라 생각하지만, 실제로는 그렇지 않다.

GC가 일어나면 GC를 담당하는 쓰레드를 제외한 모든 쓰레드들은 작동이 일시적으로 정지한다. 이를 Stop-The-World 현상이라고 한다. 모든 쓰레드가 정지되기 때문에 더 이상 작업이 실행되지 않고, 성능이 저하된다. 따라서 적절한 빈도의 GC가 실행되도록 함으로써, Stop-The-World 시간을 최소화하는 것이 중요하다.

#### Weak Generational Hypothesis

![image](https://user-images.githubusercontent.com/56240505/132839321-62d31849-2fb0-462c-bc22-c0ec6cf17a94.png)

* 최적의 GC 알고리즘을 설계하기 위한 가설로서, 대부분의 객체는 빠르게 unreachable 상태로 전환된다는 것을 상정한다.
* 오래된 영역에서 최신 영역으로의 데이터 참조가 적게 존재한다고 가정하며, Oracle Java 8 관찰 자료에서는 실제로 높은 경향성을 보인다고 밝힌 바가 있다.

#### Mark And Sweep Algorithm

![image](https://user-images.githubusercontent.com/56240505/132847606-3a5ec458-f7e0-482a-a48f-ef7bb84fd5b0.png)

* 가장 기본적인 알고리즘으로서, root set부터 출발해 참조되는 객체들에 대해서 마크를 한다.
  * 이 단계를 Mark Phase라고 한다.
* 이후에는 마크되지 않은 객체들을 추적하여 삭제하는 Sweep Phase를 진행한다.
* 메모리가 Fragmentation, 즉 단편화되는 단점이 있다.
* 메모리에서의 단편화는 정렬되지 않은 조각으로 나뉘어져, 절대적인 크기는 충분하지만 추가적으로 메모리 할당이 되기 힘든 상태가 된다.

#### Mark And Compact Algorithm

![image](https://user-images.githubusercontent.com/56240505/132847933-d4983384-1eb9-4979-a6bc-56dff32f977a.png)

* 참조되는 객체들에 대해서 마크를 하고, 참조되지 않으면 삭제를 한다.
* 이후에 메모리를 정리하여, 메모리 단편화 문제를 해결한다.
* Mark And Sweep 알고리즘의 문제를 해결하며, 많은 GC가 해당 알고리즘을 사용한다.

#### Minor GC & Major GC

![image](https://user-images.githubusercontent.com/56240505/132848076-82bcb6fd-9064-46ef-9cbb-9b09201fb4dd.png)

GC는 일어나는 시점에 따라서 크게 Minor GC 및 Major GC로 나뉜다.

1. Minor GC는 JVM의 Young 영역에서 일어나는 GC다.
  * Young에 위치한 각각의 영역이 가득 차서 새로운 객체를 생성할 수 없을 때 발생한다.
  * 객체를 최초 생성하면 Young 영역 중 Eden 영역에 위치한다.
  * Eden 영역에서 Minor GC 발생 시, 참조 중인 객체라면 Survivor1로 이동한다.
  * Survivor1에서 Minor GC 발생 시, 참조 중인 객체라면 Survivor2로 이동한다.
  * Survivor2에서 Minor GC 발생 시, 참조 중인 객체라면 다시 Survivor1 영역으로 이동하며 Survivor1과 2간 이동이 반복된다.
  * 실행 과정은 마크된 영역이 다음 영역으로 복사가 되면서 이루어진다.
  * 마크가 된 영역만 복사되기 때문에 삭제 과정은 이루어지지 않는다.
  * Major GC에 비해서 상대적으로 시간이 짧아서, Stop-The-World가 발생하는 시간이 무시할만큼 짧다.
2. Major GC는 Old 영역에서 이루어지며, 상당히 긴 시간 Stop-The-World가 발생한다.
  * Survivor 영역이 가득 차거나 Young 영역에서 오래 살아남은 객체는 Old 영역으로 이동한다.
  * 오래의 기준은 객체마다 가지고 있는 age bit다.
    * Minor GC에서 살아남은 횟수를 기록하는 값이다.
  * Old 영역에 있는 객체는 Major GC가 발생했을 때 참조 여부에 따라 공간이 유지되거나 제거된다.

<br>

---

## References

* [[C언어 강좌-2] C언어 컴파일 과정](https://gracefulprograming.tistory.com/16)
* [[비교] Native Code와 Managed Code](https://sonan.tistory.com/31)
* [Java - JIT 컴파일러](https://medium.com/@ahn428/java-jit-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-c7d068e29f45)
* [Back to the Essence - Java 컴파일에서 실행까지 - (1)](https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-1/)
* [JVM 이란?](https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2)
* [바이트코드와 바이너리 코드의 차이는 무엇일까?](https://shrtorznzl.tistory.com/82)
* [JVM에 관하여 - Part 2, ClassLoader](https://tecoble.techcourse.co.kr/post/2021-07-15-jvm-classloader/)
* [JVM에 관하여 - Part 3, Run-Time Data Area](https://tecoble.techcourse.co.kr/post/2021-08-09-jvm-memory/)
* [JVM에 관하여 - Part 4, Garbage Collection 기초](https://tecoble.techcourse.co.kr/post/2021-08-30-jvm-gc/)
