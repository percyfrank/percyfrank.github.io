---
title:  "Java Reflection과 JPA와의 관계" 
excerpt: "기본생성자 필수 생성의 이유와 생성자 수준의 상관관계 "

categories:
  - Springboot
tags:
  - Springboot

date: 2023-04-03
last_modified_at: 2023-04-03

---

### Java Reflection이란?
---

#### 정의

힙 영역에 **로드된 Class 타입**의 객체를 통해

원하는 클래스의 인스턴스, 인스턴스의 필드, 메소드를 접근 제어자와 상관없이 사용할 수 있도록 지원하는 API를 말한다.

❓ 여기서 로드된 Class란?

JVM의 클래스 로더에서 클래스 파일에 대한 로딩을 완료한 후, 해당 클래스의 정보를 담은 Class 타입의 객체를 생성하여 메모리의 힙 영역에 저장해 둔 것을 의미한다.

#### 사용 방법

Reflection 사용에 앞서, 힙 영역에 로드된 Class 타입의 객체를 가져와야 한다.

1) 클래스.class로 가져오기

2) 인스턴스.getClass()로 가져오기

3) Class.forName(”클래스명”)으로 가져오기

#### 장점 및 단점

**[ 장점 ]**

- 런타임 시점에서 클래스의 인스턴스를 생성하고, 접근 제어자와 관계 없이 필드와
메소드에 접근하여 필요한 작업을 수행할 수 있는 유연성을 가지고 있다.

**[ 단점 ]**

- 캡슐화를 저해한다.
- 런타임 시점에서 인스턴스를 생성하므로 컴파일 시점에서 타입을 체크할 수 없다.
- 런타임 시점에서 인스턴스를 생성하므로 구체적인 동작 흐름을 파악하기 어렵다.
- 단순히 필드 및 메소드를 접근할 때 보다 리플렉션을 사용하여 접근할 때 성능이 느리다.

### Reflection을 사용하는 이유
---

규모가 작은 콘솔 단계에서는 개발자가 충분히 컴파일 시점에 프로그램에서 사용될 객체와 의존관계를 모두 파악할 수 있다. 

하지만 프레임워크와 같이 큰 규모의 개발 단계에서는 수많은 객체와 의존관계를 파악하기 어렵다. 

✅ 이때 Reflection을 사용하면, **런타임** 중, 클래스 정보에 접근하여 클래스를 원하는 대로 조작할 수 있기 때문에 동적으로 클래스를 만들어서 의존관계를 맺어줄 수 있다.✅

가령 Spring의 BeanFactory를 보면 `@Controller`, `@Service`, `@Repositiory` 등의 어노테이션만 붙이면 BeanFactory에서 알아서 해당 어노테이션이 붙은 클래스를 생성하고 관리해 주는 것을 알 수 있다. 

비록 개발자가 BeanFactory에 해당 클래스를 알려준 적이 없지만 Reflection 덕분에 가능하다.

✅ 따라서, 런타임 시 해당 어노테이션이 붙은 클래스를 탐색하고 발견한다면, Reflection을 통해 해당 클래스의 인스턴스를 생성하고 필요한 필드를 주입하여 Bean Factory에 저장하는 식으로 사용이 된다.



