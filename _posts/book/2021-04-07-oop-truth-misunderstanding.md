---
title: "《객체지향의 사실과 오해》를 읽고"
excerpt: "협력이라는 문맥 안에서 책임과 역할에 초점을 맞춰 객체들을 설계하라."
categories:
  - Book
tags:
  - Book
date: 2021-04-07
last_modified_at: 2021-04-07
---

## 1. 객체지향

객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다. 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다. 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다. 객체들은 상호 작용을 통해 공동의 목표(시스템의 동작)를 이룩한다.

* 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다.
* 각 객체는 협력 내에서 정해진 역할을 수행하며, 역할은 관련된 책임의 집합이다.

### 1.1. 사실과 오해

> 객체지향은 현실 세계의 모방이다?

객체지향은 현실 세계를 기반으로 새로운 세계를 **창조**한다.

* 의인화 : 현실의 수동적인 객체는 소프트웨어에서 능동적이고 자율적인 객체가 되며, 현실에서 가질 수 없는 추가적인 행위까지 가진다.
* 은유 : 소프트웨어의 객체는 현실 속의 객체에 대한 은유다.

문제는 의인화 및 은유로 인해 표현적, 의미적인 간극이 발생한다. 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 이러한 간극을 줄여 구조 예측이 수월해진다.

> 객체지향의 핵심은 클래스다?

객체지향 세계에서 가장 중요한 것은 협력에 참여하는 동적인 객체들이다. 클래스는 동적인 객체들의 행위를 '시간에 정적인' 텍스트로 표현하는 추상화 도구다. 단순히 상태 데이터를 품고 있는 정도로 클래스를 생각하면, 객체의 캡슐화 저해 및 클래스간 강결합 등을 유발한다.

* 클래스는 협력에 참여하는 객체를 생성하는데 필요한 구현 메커니즘의 한 가지에 불과하다.
* 예를 들어, Javascirpt는 클래스 없이 객체를 사용한다.

<br>

## 2. 객체

객체는 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것이다. 현실 세계에서 볼 수 있는 물리적인 사물부터 추상적인 개념까지 모두 포함한다. 객체는 다음과 같은 특성을 가진다.

* 변경 가능한 상태.
* 특징적인 행동.
* 구별가능한 식별자.

### 2.1. 프로퍼티

프로퍼티란 객체의 상태를 구성하는 모든 특징, 즉 속성을 의미한다. 일반적으로 고정되기 때문에 정적이다.

* 프로퍼티 값은 시간의 흐름에 따라 변하는 동적인 특징을 가진다.
* 프로퍼티 타입은 단순한 값부터 객체까지 모든 것이 될 수 있다.

### 2.2. 상태와 행동

객체는 상태를 가지며 상태는 변경 가능하다. 또한 객체의 상태를 변경시키는 것은 객체의 행동이다. 행동의 결과는 상태 의존적이며 상태를 이용해 서술 가능하다. 객체는 협력하는 다른 객체에 요청 메시지를 전송하도록 행동한다.

> **협력이라는 문맥 안에서 책임(행동)에 초점을 맞춰 객체들을 설계하면, 자연스럽게 적절한 상태를 선택하게 된다.**

즉, 행동이 상태를 결정한다. 반면 상태(데이터)를 먼저 고려하며 객체를 설계하는 습관은 옳지 못하다.

* 캡슐화가 저해된다.
* 객체를 협력자가 아닌 고립된 섬으로 만든다.
* 객체의 재사용성이 저해된다.

### 2.3. 식별자

객체가 식별 가능하다는 것은 객체를 서로 구별할 특정 프로퍼티가 객체 안에 존재함을 의미한다. 해당 프로퍼티를 식별자라고 한다.

* 값 : 숫자, 문자열, 날짜 등 VO처럼 값 자체를 모델링하는 불변 상태다.
  * 식별자가 없어, 동일성이 아닌 동등성 검사를 진행한다.
* 객체 : 시간에 따라 변경되는 상태를 포함하며 행동을 통해 상태가 가변된다.
  * 참조 객체 또는 엔티티가 식별자를 가진 전통적인 의미의 객체이다.
  * 상태를 기반으로 두 객체의 동일성을 판단할 수 없고, 동일성 판단을 위해 독립적인 식별자가 필요하다.

<br>

## 3. 추상화와 타입

### 3.1. 추상화

추상화는 복잡성을 이해하기 쉬운 수준으로 단순화 하는 것이다.

* 사물들의 공통점은 취하고 차이점을 버리는 일반화 특징이 있다.
* 중요 부분을 강조하기 위해 불필요한 세부 사항을 제거한다.

객체지향은 객체라는 추상화를 통해 현실 세계의 복잡성을 극복한다. 또한 분류는 추상화를 위한 도구다.

* 객체는 특정한 개념을 적용할 수 있는 구체적인 사물이며, 우리는 개념을 통해 객체를 여러 그룹으로 분류한다.
* 개념이 객체에 적용될 때 해당 객체는 개념의 인스턴스가 된다.

### 3.2. 타입

객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다. 객체들이 동일한 행동(책임)을 수행할 수 있다면 해당 객체들은 동일한 타입이다.

* 동일한 책임이란 동일한 메시지를 수신할 수 있음을 의미한다.
* 객체의 내부 표현은 외부로부터 철저하게 감춰진다.
  * 행동을 효과적으로 수행할 수 있다면 내부 상태를 어떤 방식으로 표현해도 무방하다.

클래스와 타입은 동일한 개념이 아니다. 타입은 객체를 분류하기 위해 사용하는 개념이다.

* 클래스는 OOP 언어에서 타입을 구현하는 보편적인 방법일 뿐이다.
* 클래스는 타입 구현 이외에도 코드 재사용 등의 용도로 사용된다.

### 3.3. 일반화와 특수화

일반적인 타입은 슈퍼타입(부모)이며, 특수한 타입은 서브타입(자식)이다. 일반화는 추상화를 위한 도구다.

* 두 타입간의 관계는 행동에 의해 결정된다.
* 서브타입은 슈퍼타입의 행위와 호환되기 때문에, 서브타입은 슈퍼타입을 대체할 수 있어야 한다. (리스코프 치환 원칙)

<br>

## 4. 협력, 책임, 역할

협력은 객체들간의 일련의 요청 및 응답 등의 상호작용으로 구성된다. 메시지는 협력을 위해 객체가 다른 객체로 접근할 수 있는 유일한 방법이다.

책임은 객체에 의해 정의되는 응집도 있는 행위의 집합이다. 책임은 객체 외부에 제공해줄 수 있는 정보와 서비스의 목록, 즉 객체의 공용 인터페이스를 구성한다. 책임 수행 방법은 객체가 자율적으로 선택한다.

역할은 책임의 집합이다. 역할은 대체 가능성을 의미한다.

* 여러 객체가 동일 역할을 수행할 수 있다.
* 한 객체가 여러 역할을 수행할 수 있다.

역할의 핵심은 시스템 상의 유사한 협력을 추상화할 수 있다. 협력을 단순하고 유연하게 만들 뿐만 아니라, 재사용성도 증가한다.

* **역할은 협력 내에서 특정 객체를 다른 객체로 대체할 수 있음(다형성)을 나타낸다.**

<br>

## 5. 책임과 메시지

책임이란 요청을 처리할 때 수행하는 행동이다. 어떻게 요청을 처리할지는 객체가 자율적으로 선택해야 한다. 책임이 수행 방법을 제한할 정도로 구체적이거나, 반대로 협력 의도를 너무 표현하지 못할 정도로 추상적이면 안 된다. 자율적인 책임은 How가 아닌 What을 객체가 해야하는지 설명해야 한다.

* 절차지향언어 : 프로시저 호출에 대한 실행 코드를 컴파일 타임에 결정한다.
* 객체지향언어 : 메시지를 수신한 객체가 런타임에 메서드를 선택한다.
  * 요청을 처리할 수 있다면 적합한 메서드를 선택한다.

### 5.1. 다형성

다형성이란 서로 다른 타입에 속한 객체들이 동일 메시지를 수신한 경우, 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘이다. 다형성을 만족하기 위해서는 객체들이 동일한 책임을 공유해야 한다. 동일 역할을 공유하는 객체들간 대체 가능성이 존재한다.

객체들은 메시지로만 상호작용하며 그 외는 노출하지 않는다. 따라서 다형성의 특징은 다음과 같다.

* 메시지 송신자는 수신자의 종류를 몰라도 메시지 전송이 가능하다.
  * 다형성으로 수신자 종류를 캡슐화할 수 있다.
  * 나의 요청만 처리할 수 있다면야 어떤 객체라도 협력한다.  
* 송신자와 수신자 사이의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 다형성이 달성된다.
* 협력이 유연해지고, 협력이 수행되는 방식의 확장 및 재사용이 가능해진다.

### 5.2. 디미터의 법칙

> Tell, don't ask.

메시지를 결정하기 전까지는 수신 객체에 대해 고민하지 말아야 한다. 메시지가 결정된 후에야 해당 메시지를 처리할 객체를 선택한다. 따라서 메시지 송신 객체는 메시지를 수신할 객체의 내부 상태를 미리 알 수 없다. 이 때문에 송신자와 수신자간 결합이 느슨해진다.

* 어떤 객체인지 몰라 꼬치꼬치 캐물을 수 없으며, 객체는 다른 객체의 결정에 일절 간섭하지 않는다.
  * 모든 객체는 자신의 상태를 기반으로 자율적인 결정을 내린다.
  * 다른 객체의 상태를 묻지 말아야한다.
* 디미터 법칙은 인터페이스의 크기를 줄이며, 이를 통해 외부에서 해당 객체에 의존하는 부분이 줄어든다.

<br>

## 6. 인터페이스

인터페이스는 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 장치 혹은 방법이다. 객체의 공용(public) 인터페이스는 객체가 수신할 수 있는 메시지의 목록이다. 메서드는 책임을 수행하는 방법이다.

* 사용법을 익히면 내부 구조 동작 방식을 몰라도 대상을 쉽게 조작할 수 있다.
* 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스에 영향을 끼치지 않는다.
* 대상이 변경되더라도 동일 인터페이스를 제공하기만 하면 문제 없이 상호작용할 수 있다.

### 6.1. 인터페이스 법칙

추상적인 수준의 인터페이스를 제공하여 수신자의 자율성을 보장해야 한다. 또한 외부에서 사용할 필요가 없는 인터페이스는 노출하지 않는다.

* 최소로 유지해야 객체 내부 동작에 대한 정보 노출의 범위를 줄일 수 있다.
* 내부를 수정해도 외부에 미치는 영향이 최소화된다.

### 6.2. 인터페이스-구현 분리 원칙

소프트웨어는 항상 변경되며, 객체의 내부 정보가 외부로 공개되어 있으면 작은 부분을 수정할 때 변경에 의한 파급 효과가 시스템 전체로 퍼진다. 객체 내부는 변경에 대한 안전지대이며, 객체 공용 인터페이스는 위험지대이다.

* 메시지로 구성된 공용 인터페이스와 구현을 명확하게 구분하면, 객체의 내부와 외부가 분리된다.
  * 객체의 자율성이 높아지며, 외부에 상관없이 메시지 처리 메서드를 스스로 선택할 수 있다.
  * 외부 객체는 메시지만 알 뿐, 내부 처리 방법은 알 수 없다.

이를 통해 변경이 빈번한 정보, 상태, 행위 등을 외부로부터 은닉하는 **캡슐화**를 실현할 수 있다.

### 6.3. 자율적인 객체

자율적인 객체는 협력하는 외부 객체에 영향을 끼치지 않으면서 내부 구현을 자유롭게 수정하는 장점이 있다.

* 내부 구현 변경에 따른 외부에 대한 파급 효과를 최소화한다.
* 외부 객체는 공용 인터페이스에만 의존하게 한다.

자율적인 책임은 협력을 단순하게 만든다. 또한 협력의 대상을 다양하게 선택하는 유연성을 제공한다. 객체가 수행하는 책임들이 자율적일수록 객체의 역햘을 이해하기 쉽다.

* 객체의 응집도를 높은 상태로 유지할 수 있다.
* 높은 추상도와 응집도 및 낮은 결합도는 캡슐화와 인터페이스-구현 분리로 연결된다.
  * 이는 곧 객체지향의 여러 장점(설계 유연성 및 재사용성)으로 이어진다.

<br>

## 7. 도메인 모델

소프트웨어는 미래의 변경에 대해 유연하게 대처할 수 있는 안정적인 설계 구조를 가져야 한다. 그렇지 않으면 변경으로 인한 파급효과로 유지보수가 어려워진다. 좋은 시스템은 사용자에게 제공할 기능과, 기능을 담을 안정적인 구조의 조화에서 비롯된다.

* 도메인 : 사용자가 프로그램을 통해 해결하고자 하는 대상 영역이다.
* 모델 : 대상을 단순화해서 개념적으로 표현하는 것으로, 추상화를 통해 복잡성을 감소시킨다.

도메인 모델이란, 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 것이다.

### 7.1. 안정적인 구조

소프트웨어는 사용자들이 기대하는 바를 반영, 즉 도메인 모델을 기반으로 설계되어야 한다. 즉, 사용자가 도메인을 바라보는 관점을 코드에 반영한다. 이는 표현, 의미의 간극이 줄어 소프트웨어에 대한 이해 및 수정이 쉬워진다. 또한 도메인 지식 기반으로 코드 구조 혹은 의미를 쉽게 유추할 수 있어 유지보수성이 좋아진다.

도메인 모델은 구조가 상대적으로 안정적이다. 도메인의 본질(사용자의 관점)은 변경이 적고 특성이 오래 간다. 비즈니스 정책에 큰 개편이 없다면 도메인 모델을 구성하는 개념 및 개념들간의 관계가 안정적임을 의미한다. 또한 도메인 모델에 포함된 개념 규칙은 변경될 확률이 적다.

변경이 발생하더라도 도메인 모델 기반으로 작성된 시스템은 큰 변화 없이 요구사항 충족이 가능하다. 변경에 대한 파급력이 낮고 유연하게 대처할 수 있다.

### 7.2. 유스케이스

유스케이스란 사용자의 목표 달성을 위해 시스템간 이루어지는 상호작용의 흐름(시나리오)을 텍스트로 정리한 것이다.

* 불안정한 기능을 서술하는데 사용되는 도구이며, 피쳐 목록과는 다르다.

객체지향의 궁극적인 목표는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분배하는 것이다. 시스템에 할당된 커다란 책임을 시스템 안의 작은 규모 객체들이 수행해야 할 책임으로 잘게 세분화한다.

* 도메인 모델링에서 사용한 객체와 개념을 프로그래밍 설계의 객체와 클래스로 매끄럽게 변환이 가능하다.

이러한 연결 완전성은 역방향도 성립한다. 즉, 코드의 수정이 모델의 수정을 뜻하게 된다.

<br>

---

## References

* 객체지향의 사실과 오해(조영호 저)
